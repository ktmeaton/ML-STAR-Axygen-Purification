// ======================================================================
// This is a part of the HSL Instrument Library.
// Copyright (C) by HAMILTON Bonaduz AG, CH-7402 Bonaduz.
// All rights reserved.
// ======================================================================
//
// Modification History
//   
//	2001-11-14   bandenmatten :	Changed file name from HSLInstrument.hs_ to HSLML_STARLib.hs_
//	2001-11-14   bandenmatten :	Inserted functions HSLInstrument::MeasureContainerVolume() and 
//											HSLInstrument::GetContainerVolume().
//	2001-11-22   bandenmatten :	Used element function sequence.GetUsedPositions() to calculate the 
//											numberOfUsedPositions in function MeasureContainerVolume().
//	2002-01-21   bandenmatten :	Added function CreateATBarcodefile().
//	2002-02-05   bandenmatten :	Added functions:
//												DeleteBarcodeFile()
//												FormatBarcodeFile()
//												ExecuteWorklist()
//	2002-02-21   bandenmatten :	Replaced evaluation of return value of FirmawareCommand::Execute():
//											rc.GetAt(3) -> rc.GetAt(rc.GetSize() - 1).
//	2002-03-06   bandenmatten :	Fixed a bug in DeckDef::GetLabwareAtSites() (ba 2002-03-06 begin).
//	2002-03-14   bandenmatten :	Function StepReturn::Evaluate and StepReturn::EvaluateEx :
//											Added new parameter 'ML_STAR'.
//	2002-03-14   bandenmatten :	Function StepReturn::Evaluate and StepReturn::EvaluateEx :
//											Initialized field and block delimiters used in step returns from 
//											the device's configuration file.
//	2002-03-14   bandenmatten :	Function DeckDef::GetLabwareAtSites :
//											Initialized DeckDef::deckRaster etc. from the device's configuration file 
//	2002-04-30   bandenmatten :	Semaphore 'hslML_STARLibCs' was not initialized in the functions listed below
//											(they don't call InitHSLML_STARLibrary(ml_star) to avoid the execution of the firmware command in getNumberOfChannels):
//												CreateATBarcodefile()
//												DeleteBarcodeFile()
//												FormatBarcodeFile()
//												ExecuteWorklist()
//											Fixed this bug by introducing new initialization function InitHSLML_STARLibraryCore() (ba 2002-04-30 begin).
//	2002-06-06   bandenmatten :	Fixed a bug in DeckDef::GetLabwareAtSites() (ba 2002-06-06 begin).
//	2002-06-07   bandenmatten :	Function FormatBarcodeFile(): Replaced references of variable 'site' by variable 'position'.
//	2002-06-20   bandenmatten :	Edited all low level steps to convert long CfgFil keywords to short CfgFil keywords.
//	2002-06-20   bandenmatten :	Edited all low level steps to convert step file from text form to binary form.
//	2002-06-20   bandenmatten :	Removed unsupported function sequence.IterateLabware().
//	2002-06-20   bandenmatten :	Added filter types to TipType and TipTypeNum.
//	2002-07-01   bandenmatten :	Changed the functions FormatBarcodeFile() and ExecuteWorklist() to search 
//											a relative barcode or worklist file in the LogFiles directory too.
//	2002-12-04   bandenmatten :	Function MeasureContainerVolume(): Set the number of used positions on the 
//											'targetSequence', so that the client can get the number of used positions to 
//											increment the sequence manually.
//	2002-12-04   bandenmatten :	Function MeasureContainerVolume(): Made error recovery option 'Abort' invisible in 
//											the Aspirate step (AusBio).
//	2003-01-10   bandenmatten :	Function EvaluateAspirateRecovery(): Not all paths through the function returned a value. Fixed this bug. 
//	2004-03-03	 calig		  :	Added new function GetInstrumentType()
//	2004-03-19	 calig		  :	Added new function GetInstrumentType_GlobalDevice()
//	2004-04-05   bandenmatten :	Added include of HSLMlStarCfgKeys.hs_ (reason: syntax errors).
//	2004-04-05   bandenmatten :	If a carrier didn't have any barcode properties defined (e.g. MlStarCarCountOfBCPos), 
//											the function FormatBarcodeFile() reported an error (Array index out of bound). 
//											Fixed this bug in function DeckDef::GetLabwareAtSites().
//	2004-04-05   bandenmatten :	Function FormatBarcodeFile(): Opening the unformatted barcode file results in a Phoenix Error 
//											if the regional settings use the comma as decimal symbol. Fixed this bug.
// 2004-04-05  bandenmatten :		If the error handling was set to ErrorHandling::continue and the user selected the Cancel button
//											in the recovery options of the low level step executed in the ExecuteWorklist() function, the 
//											library didn't return with an exption but continued with the next statements. Fixed this bug by 
//											introducing the function EvaluateGenericRecovery().
// 2004-04-05  bandenmatten :		Function MeasureContainerVolume(): Took Max of targetSequence into account.
// 2004-04-15  cjoerg		:		- Declare return type of all exported functions.
//											- Add function IsSimulatorMode().
//											- Change implementation of functions GetInstrumentType(), GetInstrumentType_GlobalDevice()
//											  to be more flexible. Add some traces.
//											- Functions updated for working well also in the simulator mode.
//												- AspirationMonitoringOn() / AspirationMonitoringOff()
//												- ClotDetectionMonitoringOn() / ClotDetectionMonitoringOff()
//												- SetPressureThreshold()
//											- SetPressureThreshold() fixed that it works also if _DEBUG is set.
//											- Move some strings for error message boxes to the string table:
//												- FirmwareError::ErrorCheck()
//												- SetPressureThreshold()
// 2004-04-16  cjoerg		:		- In GetContainerVolume() into the library core first.
//											- GetInstrumentType(): Changed that the function trace is done before the local 
//                                 device is created.
// 2005-05-18	bandenmatten :		SCR#836: Added new function MeasureContainerVolume2().
// 2005-07-26	bandenmatten :		Function ExecuteWorklist() didn't support filter-tip-types --> added support for filter-tip-types to function PCB::TrackVolume().
// 2006-04-10	bandenmatten :		Added new functions:	- HSLML_STAR::AntiDropletControlOn().
//																		- HSLML_STAR::AntiDropletControlOff().
//																		- HSLML_STAR::SetBarcodeTypes().
// 2006-05-03  bandenmatten :		Called GetWorkflowFileName() if GetMethodFileName() returned the empty string.
// 2006-06-21  bandenmatten :		Renamed include file: #include "HSLUtilLib2.hs_" --> #include "HSLUtilLib2.hsl"
// 2007-10-03	ubernhard :			Added new functions:
//												- AspirationMonitoring_5mlChannel_On()
//												- AspirationMonitoring_5mlChannel_Off()
//												- ClotDetectionMonitoring_5mlChannel_On()
//												- ClotDetectionMonitoring_5mlChannel_Off()
//												- AntiDropletControl_5mlChannel_On()
//												- AntiDropletControl_5mlChannel_Off()
//												- SetPressureThreshold_5mlChannel()
//												- AspirationMonitoring_1000ulChannel_On()
//												- AspirationMonitoring_1000ulChannel_Off()
//												- ClotDetectionMonitoring_1000ulChannel_On()
//												- ClotDetectionMonitoring_1000ulChannel_Off()
//												- AntiDropletControl_1000ulChannel_On()
//												- AntiDropletControl_1000ulChannel_Off()
//												- SetPressureThreshold_1000ulChannel()
//											Declared following functions as static (new naming due to new 5ml channels):
//												- AspirationMonitoringOn()
//												- AspirationMonitoringOff()
//												- ClotDetectionMonitoringOn()
//												- ClotDetectionMonitoringOff()
//												- AntiDropletControlOn()
//												- AntiDropletControlOff()
//												- SetPressureThreshold()
//
// ======================================================================

#ifndef __HSLML_STARImpl_hsl__
#define __HSLML_STARImpl_hsl__	1

#ifndef __HSLStrLib_hsl__
#include "HSLStrLib.hsl"
#endif

#ifndef __HSLMlStarStepReturnLib_hsl__
#include "HSLMlStarStepReturnLib.hsl"
#endif

#ifndef __HSLMlStarStepLib_hs___
#include "HSLMlStarStepLib.hs_"
#endif

#ifndef __HSLTipContingLib_hsl__		// The define ist spelled correctly!	
#include "HSLTipCountingLib.hsl"
#endif

#ifndef __HSLSeqLib_hsl__
#include "HSLSeqLib.hsl"
#endif

#ifndef __HSLSynLib_hsl__
#include "HSLSynLib.hsl"
#endif

#ifndef __HSLFilLib_hsl__
#include "HSLFilLib.hsl"
#endif

#ifndef __HSLMlStarCfgKeys_hs___
#include "HSLMlStarCfgKeys.hs_"
#endif

#ifndef __HSLUtilLib2_hsl__
#include "HSLUtilLib2.hsl"
#endif

#ifndef __HSLUtilLib2Def_hs___
#include "HSLUtilLib2Def.hs_"
#endif

//device ML_STAR;

// --------------------------------------------------------------------------------------
// Implementation of File library 
// --------------------------------------------------------------------------------------

namespace HSLML_STAR
{	
	#ifndef __HSLStringTableLib_hsl__
	#include "HSLStringTableLib.hs_"
	#endif

	// --------------------------------------------------------------------------------------
	// Command interpreter
	// --------------------------------------------------------------------------------------
	namespace CmdInterpreter
	{
		#define _WINNT	1
		// #define _WIN98	1 
		#ifdef _WINNT
		static variable cmdPrompt("cmd.exe");
		#endif
		#ifdef _WIN98
		static variable cmdPrompt("command.com");
		#endif
	}

	// --------------------------------------------------------------------------------------
	// Debugging and Developing
	// --------------------------------------------------------------------------------------

//	#define _DEBUG		1		// specifies the debug version of the HSLML_STAR library

	// --------------------------------------------------------------------------------------
	// Error Ids
	// --------------------------------------------------------------------------------------
	
	namespace IDE
	{
		static const variable first(0);											// guard
		static const variable noError(first);									// No error
		static const variable fatalError(first + 1);							// General unspecific error
		static const variable invalidChannelPattern(first + 2);			// The channel pattern is invalid.
		static const variable invalidChannelNumber(first + 3);			// The channel number is invalid.
		static const variable invalidLLDSensitivity(first + 4);			// The liquid level detection sensitivity is invalid.
		static const variable invalidMaxHeightDifference(first + 5);	// The maximum height difference is invalid.
		static const variable methodAborted(first + 6);						// The method was aborted by the user.
		static const variable invalidFileName(first + 7);					// The specified file name is invalid.
		static const variable fileOpenFailed(first + 8);					// The system cannot open the file '%s'.
		static const variable fileWriteFailed(first + 9);					// The system cannot write the device or file specified.
		static const variable noBarcode(first + 10);							// The barcode '%s' was not found in the barcode file.
		static const variable noLabware(first + 11);							// The labware with barcode '%s' was not found in the barcode file.
		static const variable noPosition(first + 12);						// Found no position for labware '%s'.
		static const variable invalidVolume(first + 13);					// The volume is invalid.
		static const variable expectedLabwareIdOrBarcode(first + 14);	// Expected either a labware identification or a barcode.
		static const variable invalidTipType(first + 15);					// The tip type is invalid.
		static const variable invalidLiquidClass(first + 16);				// The liquid class is invalid.
		static const variable missingLiquidClass(first + 17);				// The liquid class is not specified.
		static const variable invalidStepType(first + 18);					// The step type is invalid.
		static const variable invalidLiquidClassValue(first + 19);		// The value of the extended liquid class property '%s' is invalid.
		static const variable unexpectedEndOfFile(first + 20);			// Unexpected end of file.
		static const variable fileNotFound(first + 21);						// The system cannot find the file '%s'.
		static const variable labwareDataKeyNotFound(first + 22);		// The key '%s' was not found in the labware data.
		static const variable multipleLiquidClasses(first + 23);			// All channels in an Aspirate or Dispense step must have the same liquid class.
		static const variable firmwareErrorTitle(first + 24);				// Firmware Error -> MsgBox Title
		static const variable firmwareError(first + 25);					// Firmware Error -> MsgBox Text 1
		static const variable firmwareErrorDescription(first + 26);		// Firmware Error -> MsgBox Text 2
		static const variable invalidParameterTitle(first + 27);			// Invalid parameter -> MsgBox Title
		static const variable invalidParameterType(first + 28);			// Invalid parameter type
		static const variable invalidParameterRange(first + 29);			// Parameter out of range
		static const variable invalidBarcodeTypesString(first + 30);	// The barcode types string is invalid (expected characters '0' or '1').
		static const variable firmwareError2(first + 31);					// Failed to execute the firmware command '%s1'.Firmware error: '%s2'.
		static const variable last(first + 31);								// guard
	}

	// --------------------------------------------------------------------------------------
	// String Ids
	// --------------------------------------------------------------------------------------

	namespace IDS
	{
		static const variable first(IDE::last + 1);										// guard
		static const variable traceSource(first);											// source for formated trace
		static const variable traceActionAspirationMonitoringOn(first + 1);		// action for formated trace
		static const variable traceActionAspirationMonitoringOff(first + 2);		// action for formated trace
		static const variable traceActionClotDetectionMonitoringOn(first + 3);	// action for formated trace
		static const variable traceActionClotDetectionMonitoringOff(first + 4);	// action for formated trace
		static const variable traceActionSetPressureThreshold(first + 5);			// action for formated trace
		static const variable traceErrorInvalidDatatype(first + 6);					// error for formated trace
		static const variable traceErrorInvalidArgument(first + 7);					// error for formated trace
		static const variable traceActionMeasureContainerVolume(first + 8);		// action for formated trace
		static const variable helpFileName(first + 9);									// help file name
		static const variable traceActionCreateATBarcodefile(first + 10);			// action for formated trace
		static const variable traceCarrier(first + 11);									// carrier
		static const variable tracePlate(first + 12);									// plate
		static const variable traceLabwareIdNotFound(first + 13);					// The labware id of the plate was not found in the deck layout definition file.
		static const variable traceActionDeleteBarcodeFile(first + 14);			// action for formated trace
		static const variable traceActionFormatBarcodeFile(first + 15);			// action for formated trace
		static const variable traceActionExecuteWorklist(first + 16);				// action for formated trace
		static const variable noBarcode(first + 17);										// No barcode
		static const variable noLabware(first + 18);										// No labware
		static const variable traceNewFunction(first + 19);							// Please take the new function from library '???'.");
		static const variable simulatorModeFirmwrCmdNotExecuted(first + 20);		// Trace simulator mode, function only simulated.
		static const variable traceActionGetInstrumentType(first + 21);			// action for formated trace
		static const variable traceActionGetInstrumentTypeNoInstr(first + 22);	// action for formated trace
		static const variable evaluatedInstrumentType(first + 23);					// evaluated instrument type
		static const variable traceActionAntiDropletControlOn(first + 24);		// action for formated trace
		static const variable traceActionAntiDropletControlOff(first + 25);		// action for formated trace
		static const variable traceActionSetBarcodeTypes(first + 26);				// action for formated trace
		static const variable traceActionAspMonitoring_5ml_On(first + 27);		// action for formated trace
		static const variable traceActionAspMonitoring_5ml_Off(first + 28);		// action for formated trace
		static const variable traceActionClotDetMonitoring_5ml_On(first + 29);	// action for formated trace
		static const variable traceActionClotDetMonitoring_5ml_Off(first + 30);	// action for formated trace
		static const variable traceActionSetPressureThreshold_5ml(first + 31);	// action for formated trace
		static const variable traceActionADC_5ml_On(first + 32);						// action for formated trace
		static const variable traceActionADC_5ml_Off(first + 33);					// action for formated trace
		static const variable last(first + 33);											// guard
	}

	// --------------------------------------------------------------------------------------
	// Error Handling
	// --------------------------------------------------------------------------------------

	namespace ErrorHandling
	{
		static const variable first(1);									// guard
		static const variable abort_(first);							// error handling
		static const variable cancel(first + 1);						// error handling
		static const variable continue(first + 2);					// error handling
		static const variable last(first + 2);							// guard
	}

	// --------------------------------------------------------------------------------------
	// Traceing
	// --------------------------------------------------------------------------------------

	namespace TraceStatus
	{
		static const variable start(1);									// action status for formated trace
		static const variable complete(2);								// action status for formated trace
		static const variable error_(3);									// action status for formated trace
		static const variable progress(4);								// action status for formated trace
		static const variable completeWithError(5);					// action status for formated trace
	}

	// --------------------------------------------------------------------------------------
	// Firmware Command
	// --------------------------------------------------------------------------------------

	namespace FirmwareCommand
	{
		// functions
		static function Execute(											// executes a firmware command
			device& ML_STAR,													// i: pipetting device
			variable& command,												// i: command (string)
			variable& parameter);											// i: parameter (string)
	}

	// --------------------------------------------------------------------------------------
	// Global data
	// --------------------------------------------------------------------------------------

	namespace Global
	{
		// 1000ul channels
		variable numberOfChannels;											// Number of pipetting channels
		variable channel[];													// Array for the channel names P1..P16
		variable currentPipConfigOfTipRecognition[];					// Pipetting configuration: Type of tip recognition
		variable currentPipConfigAspMonWithPLLD[];					// Pipetting configuration: Aspiration and clot detectionmonitoring with the pLLD
		variable currentPipConfigAspMonWithCLLD[];					// Pipetting configuration: Aspiration monitoring with cLLD
		variable currentPipConfigClotMonWithCLLD[];					// Pipetting configuration: Clot detection monitoring with cLLD

		// 5ml channels
		variable numberOf_5mlChannels;									// Number of pipetting channels
		variable channelNode_5ml[];										// Array for the channel names L1..L8
		variable currentPipConfigOfTipRecognition_5mlChannels[];	// Pipetting configuration: Type of tip recognition
		variable currentPipConfigAspMonWithPLLD_5mlChannels[];	// Pipetting configuration: Aspiration and clot detectionmonitoring with the pLLD
		variable currentPipConfigAspMonWithCLLD_5mlChannels[];	// Pipetting configuration: Aspiration monitoring with cLLD
		variable currentPipConfigClotMonWithCLLD_5mlChannels[];	// Pipetting configuration: Clot detection monitoring with cLLD

		variable containerVolume[];										// Place to hold container volumes measured during the MeasureContainerVolume operation
		static const variable maxNumberOfRetries(2);					// Max number of retries to detect liquid level
		static const variable maxNumberOfChannels(16);				// Max number of channels
	}

	// --------------------------------------------------------------------------------------
	// Utilities
	// --------------------------------------------------------------------------------------

	namespace Util
	{
		// functions

		static function IsString(								// returns true if the variable value is a string
			variable var);											// i: variable

		static function IsNumber(								// returns true if the variable value is a number
			variable var);											// i: variable

		static function IsInteger(								// returns true if the variable value is an integer
			variable var);											// i: variable

		static function IsFloat(								// returns true if the variable value is a float
			variable var);											// i: variable

		static function IsNegative(							// returns true if the number is negative
			variable number);										// i: number

		static function Abs(										// returns a value of the same type that is passed to it specifying the absolute value of a number
			variable number);										// i: number

		static function FillLeft(								// fills leading characters to the string
			variable& str,											// i: string
			variable& character,									// i: character
			variable width);										// i: width

		static function FillRight(								// fills trailing characters to the string
			variable& str,											// i: string
			variable& character,									// i: character
			variable width);										// i: width

		static function Min(										// returns the lesser of two numeric (or string) expressions 
			variable number1,										// i: expression 1
			variable number2);									// i: expression 2

		static function NumberOfActiveChannels(			// returns the number of active channels
			string& channelPattern);							// i:	channel pattern

		static function Max(										// returns the greater of two numeric (or string) expressions 
			variable var1,											// i: expression 1
			variable var2);										// i: expression 2

		static function Lookup(									// returns true if the array of variables contains the value specified 
			variable& varArr[],									// i: array of variables
			variable& value,										// i: value to lookup
			variable& index);										// o: zero based index of value found

		function Sort(												// bubblesort, see N.Wirth
			variable& values[],									// i: values
			variable& keys[]);									// i: keys
	}

	// --------------------------------------------------------------------------------------
	// Exception handling
	// --------------------------------------------------------------------------------------

	namespace Error
	{
		static function Raise(												// raises a runtime error
			variable errorId,													// i: error id, one of IDE
			variable& fileName,												// i: file name
			variable& funcName,												// i: function name
			variable& lineNumber)											// i: line number
		{
			variable description("");

			// set error description
			if ("" == funcName)
				description = fileName + "(" + lineNumber + ") : " + StringTable::Load(errorId);
			else
				description = fileName + "(" + lineNumber + ") : " + funcName + "()\n" + StringTable::Load(errorId);
			err.SetDescription(description);

			// raise error
			err.Raise(errorId, err.GetDescription(), StringTable::Load(IDS::helpFileName));
		}

		static function RaiseEx(											// raises a runtime error
			variable errorId,													// i: error id, one of IDE
			variable errorDesc,												// i: error description
			variable& fileName,												// i: file name
			variable& funcName,												// i: function name
			variable& lineNumber)											// i: line number
		{
			variable description("");

			// set error description
			if ("" == funcName)
				description = fileName + "(" + lineNumber + ") : " + errorDesc;
			else
				description = fileName + "(" + lineNumber + ") : " + funcName + "()\n" + errorDesc;
			err.SetDescription(description);

			// raise error
			err.Raise(errorId, err.GetDescription(), StringTable::Load(IDS::helpFileName));
		}

		static function RaiseLast()										// re-throws the last runtime error
		{
			// re-raise error
			err.Raise();
		}
	}

	// --------------------------------------------------------------------------------------
	// Firmware Errorhandler
	// --------------------------------------------------------------------------------------

	namespace FirmwareError
	{
		static function ErrorCheck(							// return 0, if the result string contains no error
			string& result);										// otherwise the method will abort
	}								

	// --------------------------------------------------------------------------------------
	// Some prototypes of internal functions
	// --------------------------------------------------------------------------------------
		
	// Reads the current pipetting configuration of each 1000ul channel as set in the instrument (PCHN Board). 
	static function getCurrentPipettingConfiguration(device& ML_STAR);

	// Reads the number of 1000ul pipetting channels as set in the instrument (Masterboard). 
	static function getNumberOfChannels(device& ML_STAR);

	// Reads the current pipetting configuration of each 5ml channel as set in the instrument (PCHN Board). 
	static function getCurrentPipettingConfiguration_5mlChannels(device& ML_STAR);

	// Reads the number of 5ml pipetting channels as set in the instrument (Masterboard). 
	static function getNumberOf_5mlChannels(device& ML_STAR);
	
	// --------------------------------------------------------------------------------------
	// Some prototypes of exported functions
	// --------------------------------------------------------------------------------------

	function IsSimulatorMode(
		device& ml_star) variable;

	// --------------------------------------------------------------------------------------
	// Library Synchronization 
	// --------------------------------------------------------------------------------------

	static global variable hslML_STARLibCs(0);						// critical section

	// --------------------------------------------------------------------------------------
	// Library Initialization
	// --------------------------------------------------------------------------------------

	static variable initializedLib(hslFalse);							// initialization state of the HSLML_STAR library
	static function InitHSLML_STARLibrary(device& ML_STAR);		// initializes the HSLML_STAR library (only once)

	static function InitHSLML_STARLibraryCore()
	{
		if (!initializedLib)
			StringTable::Init("HSLML_STARStringTable");

		if (0 == hslML_STARLibCs)
			hslML_STARLibCs = SynInitializeCriticalSection();
	}

	static function InitHSLML_STARLibrary(device& ML_STAR)
	{
		// initialize the HSLML_STAR library once only
		if (!initializedLib)
		{
			// initialize the core of HSLML_STAR library
			InitHSLML_STARLibraryCore();
					
			//initalize channel[] array
			Global::channel.AddAsLast("P1");
			Global::channel.AddAsLast("P2");
			Global::channel.AddAsLast("P3");
			Global::channel.AddAsLast("P4");
			Global::channel.AddAsLast("P5");
			Global::channel.AddAsLast("P6");
			Global::channel.AddAsLast("P7");
			Global::channel.AddAsLast("P8");
			Global::channel.AddAsLast("P9");
			Global::channel.AddAsLast("PA");
			Global::channel.AddAsLast("PB");
			Global::channel.AddAsLast("PC");
			Global::channel.AddAsLast("PD");
			Global::channel.AddAsLast("PE");
			Global::channel.AddAsLast("PF");
			Global::channel.AddAsLast("PG");

			Global::channelNode_5ml.AddAsLast("L1");
			Global::channelNode_5ml.AddAsLast("L2");
			Global::channelNode_5ml.AddAsLast("L3");
			Global::channelNode_5ml.AddAsLast("L4");
			Global::channelNode_5ml.AddAsLast("L5");
			Global::channelNode_5ml.AddAsLast("L6");
			Global::channelNode_5ml.AddAsLast("L7");
			Global::channelNode_5ml.AddAsLast("L8");

			// initalize variable Global::numberOfChannels
			getNumberOfChannels(ML_STAR);
			// initalize variable Global::numberOf_5mlChannels
			getNumberOf_5mlChannels(ML_STAR);
 
			initializedLib = hslTrue;

		}
		return(initializedLib);
	}

	// --------------------------------------------------------------------------------------
	// Implementation 
	// --------------------------------------------------------------------------------------
	
	static function Util::IsString(variable var)
	{
		return(hslString.Compare(GetType(var)) == 0);
	}

	static function Util::IsNumber(variable var)
	{
		variable type;
		type = GetType(var);
		return(hslString.Compare(type) != 0 && "" != type);
	}

	static function Util::IsInteger(variable var)
	{
		return(hslInteger.Compare(GetType(var)) == 0);
	}

	static function Util::IsFloat(variable var)
	{
		return(hslFloat.Compare(GetType(var)) == 0);
	}

	static function Util::IsNegative(variable number)
	{
		return(number < 0);
	}

	static function Util::Abs(variable number)
	{
		if (number < 0)
			return(- number);
		return(number);
	}

	static function Util::FillLeft(
		variable& str,
		variable& character,
		variable width)
	{
		while (StrGetLength(str) < width)
		{
			str = character + str;
		}
		return(str);
	}

	static function Util::FillRight(
		variable& str,
		variable& character,
		variable width)
	{
		while (StrGetLength(str) < width)
		{
			str = str + character;
		}
		return(str);
	}

	static function Util::Min(variable number1, variable number2)
	{
		if (number1 <= number2)
			return(number1);
		return(number2);
	}

	static function Util::NumberOfActiveChannels(
		string& channelPattern)
	{
		variable index;
		variable length;
		variable numberOfActiveChannels(0);

		length = channelPattern.GetLength();
		for (index = 0; index < length; index++)
		{
			if ("1" == channelPattern.Mid(index, 1))
				numberOfActiveChannels++;
		}
		return(numberOfActiveChannels);
	}

	static function Util::Max(variable var1, variable var2)
	{
		if (var1 <= var2)
			return(var2);
		return(var1);
	}

	static function Util::Lookup(variable& varArr[], variable& value, variable& index)
	{
		variable found(hslFalse);									// gets true if value was found in varArr
		variable size(0);												// the size of varArr
		variable isString(hslFalse);								// indicates if the value searched is of type string
		variable currentValue;

		// do a sequential search
		isString = Util::IsString(value);
		size = varArr.GetSize();
		if (isString)
		{
			for (index = 0; index < size; index++)
			{
				currentValue = varArr.GetAt(index);
				if (Util::IsString(currentValue) && currentValue == value)
				{
					found = hslTrue;
					break;
				}
			}
		}
		else
		{
			for (index = 0; index < size; index++)
			{
				currentValue = varArr.GetAt(index);
				if (Util::IsNumber(currentValue) && currentValue == value)
				{
					found = hslTrue;
					break;
				}
			}
		}
		if (!found)
			index =  0;
		return(found);
	}

	function Util::Sort(variable& values[], variable& keys[])
	{
		// bubblesort, see N.Wirth
		variable i, j, x;
		variable size;

		size = Util::Min(values.GetSize(), keys.GetSize());
		for (i = 1; i < size; i++)
		{
			for (j = size - 1; i <= j; j--)
			{
				if (keys.GetAt(j) < keys.GetAt(j-1))
				{
					x = keys.GetAt(j-1);
					keys.SetAt(j-1, keys.GetAt(j));
					keys.SetAt(j, x);

					x = values.GetAt(j-1);
					values.SetAt(j-1, values.GetAt(j));
					values.SetAt(j, x);
				}
			}
		}
	}

	namespace FirmwareCommand
	{
		static function Execute(
			device& ML_STAR,
			variable& command,
			variable& parameter)
		{
			variable rc[];

			rc = ML_STAR.FirmwareCommand( "653a3dbe_7a23_4889_94bea58d99c323e5" );

			return (rc);
		}
	}

	namespace FirmwareError
	{
		static function ErrorCheck(string& result)	// result string from firmware
		{
			variable index;

			#ifdef _DEBUG
			Trace("HSLML_STAR library - FirmwareError::ErrorCheck - begin.");
			#endif

			// lookup for "er" in the result string 
			// (note: not all firmware commands response with an error information in the result string)
			// if there is an error information within the result string it starts on index 0 
			// e.g. "er00"
			index = result.Find("er");

			if(index == 0)
			{
				string errorNr;
				string emptyString("");

				errorNr = result.Mid(2, 2);

				#ifdef _DEBUG
				Trace("Firmware Error Number: ", errorNr);
				#endif
					
				// trim leading zeros
				errorNr = StrTrimLeft( errorNr, "0" );

				if( errorNr.Compare(emptyString) != 0)
				{
					variable message;
					variable firmwareError("");

					firmwareError = result;

					message = StringTable::Load(HSLML_STAR::IDE::firmwareError);
					message = message + firmwareError;
					message = message + StringTable::Load(HSLML_STAR::IDE::firmwareErrorDescription);

					MessageBox(message, StringTable::Load(HSLML_STAR::IDE::firmwareErrorTitle), hslOKOnly | hslError);
					abort;
				}
			}

			#ifdef _DEBUG
			Trace("HSLML_STAR library - FirmwareError::ErrorCheck - complete (no firmware error found).");
			#endif
			
			return (0);
		}

		static function ErrorCheck2(			// Checks firmware result string for an error, throws an exception on failure
			variable& command,					// [in]: Command string 
			variable& result) void				// [in]: Result string 
		{
			if(0 == StrFind(result, "er"))
			{
				variable errorCode(0);
				errorCode = StrMid(result, 2, 2);
				StrTrimLeft(errorCode, "0");
				if("" != errorCode)
				{
					variable errorDesc("");

					errorDesc = StringTable::Load(IDE::firmwareError2);
					StrReplace(errorDesc, "%s1", command);
					StrReplace(errorDesc, "%s2", result);
					Error::RaiseEx(IDE::firmwareError2, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				}
			}
		}
	}

	// Reads the current pipetting configurtaion of each channel as set in the instrument (PCHN Board). 
	// Return String from Firmware e.g. "P5RAau0 1 0 1":
	// Config Information for Channel P5 is "0 1 0 1"
	// String Index 0: Flag for Tip Recognition 
	// String Index 2: Flag for Aspiration and clot detection monitoring  with the pLLD
	// String Index 4: Flag for Aspiration monitoring with the cLLD
	//	String Index 6: Flag for Clot detection monitoring with the cLLD
	static function getCurrentPipettingConfiguration(device& ML_STAR)
	{
		variable i;
		variable charAtIndex_0;
		variable charAtIndex_2;
		variable charAtIndex_4;
		variable charAtIndex_6;
		string result;
		string currentConfig;
		variable index;
		variable rc[];
		variable command("");
		variable parameter("");
		variable traceSource;

		traceSource = StringTable::Load(HSLML_STAR::IDS::traceSource);

		Global::currentPipConfigOfTipRecognition.SetSize(Global::numberOfChannels);
		Global::currentPipConfigAspMonWithPLLD.SetSize(Global::numberOfChannels);
		Global::currentPipConfigAspMonWithCLLD.SetSize(Global::numberOfChannels);
		Global::currentPipConfigClotMonWithCLLD.SetSize(Global::numberOfChannels);		

		for (i = 0; i < Global::numberOfChannels; i++)
		{			
			command = Global::channel.GetAt(i) + "RA";	//first channel is P1
			parameter = "raau";

			#ifdef _DEBUG
			Trace(command, parameter);
			#endif

			if ( IsSimulatorMode(ML_STAR) )
			{
				variable strSimMode;
				strSimMode = StringTable::Load(HSLML_STAR::IDS::simulatorModeFirmwrCmdNotExecuted);
				strSimMode = strSimMode + "'" + command + "' ; '" + parameter + "'";
				FormatTrace(ML_STAR.GetInstrumentName(), strSimMode, 4); 

				// Set only to valid values
				charAtIndex_0 = "0";
				charAtIndex_2 = "0";
				charAtIndex_4 = "0";
				charAtIndex_6 = "0";
			}
			else
			{
				rc = FirmwareCommand::Execute(ML_STAR, command, parameter);
				result = rc.GetAt(rc.GetSize() - 1);
			
				//Check for firmware error, aborts if error in returned string
				FirmwareError::ErrorCheck(result);

				index = result.Find("au");	
				currentConfig = result.Mid((index+2), 7);

				#ifdef _DEBUG
				Trace("Current Pipetting Configuration of 1000ul Channel ", Global::channel.GetAt(i), ": ", currentConfig);
				#endif

				charAtIndex_0 = currentConfig.Mid(0, 1);
				charAtIndex_2 = currentConfig.Mid(2, 1);
				charAtIndex_4 = currentConfig.Mid(4, 1);
				charAtIndex_6 = currentConfig.Mid(6, 1);
			}

			Global::currentPipConfigOfTipRecognition.SetAt(i, charAtIndex_0);
			Global::currentPipConfigAspMonWithPLLD.SetAt(i, charAtIndex_2);
			Global::currentPipConfigAspMonWithCLLD.SetAt(i, charAtIndex_4);
			Global::currentPipConfigClotMonWithCLLD.SetAt(i, charAtIndex_6);		
		}

		return (0);
	}

	// Reads the current pipetting configurtaion of each channel as set in the instrument (PCHN Board). 
	// Return String from Firmware e.g. "P5RAau0 1 0 1":
	// Config Information for Channel P5 is "0 1 0 1"
	// String Index 0: Flag for Tip Recognition 
	// String Index 2: Flag for Aspiration and clot detection monitoring  with the pLLD
	// String Index 4: Flag for Aspiration monitoring with the cLLD
	//	String Index 6: Flag for Clot detection monitoring with the cLLD
	static function getCurrentPipettingConfiguration_5mlChannels(device& ML_STAR)
	{
		variable i;
		variable charAtIndex_0;
		variable charAtIndex_2;
		variable charAtIndex_4;
		variable charAtIndex_6;
		string result;
		string currentConfig;
		variable index;
		variable rc[];
		variable command("");
		variable parameter("");
		variable traceSource;

		traceSource = StringTable::Load(HSLML_STAR::IDS::traceSource);

		Global::currentPipConfigOfTipRecognition_5mlChannels.SetSize(Global::numberOf_5mlChannels);
		Global::currentPipConfigAspMonWithPLLD_5mlChannels.SetSize(Global::numberOf_5mlChannels);
		Global::currentPipConfigAspMonWithCLLD_5mlChannels.SetSize(Global::numberOf_5mlChannels);
		Global::currentPipConfigClotMonWithCLLD_5mlChannels.SetSize(Global::numberOf_5mlChannels);		

		for (i = 0; i < Global::numberOf_5mlChannels; i++)
		{			
			command = Global::channelNode_5ml.GetAt(i) + "RA";	//first channel is P1
			parameter = "raau";

			#ifdef _DEBUG
			Trace(command, parameter);
			#endif

			if ( IsSimulatorMode(ML_STAR) )
			{
				variable strSimMode;
				strSimMode = StringTable::Load(HSLML_STAR::IDS::simulatorModeFirmwrCmdNotExecuted);
				strSimMode = strSimMode + "'" + command + "' ; '" + parameter + "'";
				FormatTrace(ML_STAR.GetInstrumentName(), strSimMode, 4); 

				// Set only to valid values
				charAtIndex_0 = "0";
				charAtIndex_2 = "0";
				charAtIndex_4 = "0";
				charAtIndex_6 = "0";
			}
			else
			{
				rc = FirmwareCommand::Execute(ML_STAR, command, parameter);
				result = rc.GetAt(rc.GetSize() - 1);
			
				//Check for firmware error, aborts if error in returned string
				FirmwareError::ErrorCheck(result);

				index = result.Find("au");	
				currentConfig = result.Mid((index+2), 7);

				#ifdef _DEBUG
				Trace("Current Pipetting Configuration of 5ml Channel ", Global::channel.GetAt(i), ": ", currentConfig);
				#endif

				charAtIndex_0 = currentConfig.Mid(0, 1);
				charAtIndex_2 = currentConfig.Mid(2, 1);
				charAtIndex_4 = currentConfig.Mid(4, 1);
				charAtIndex_6 = currentConfig.Mid(6, 1);
			}

			Global::currentPipConfigOfTipRecognition_5mlChannels.SetAt(i, charAtIndex_0);
			Global::currentPipConfigAspMonWithPLLD_5mlChannels.SetAt(i, charAtIndex_2);
			Global::currentPipConfigAspMonWithCLLD_5mlChannels.SetAt(i, charAtIndex_4);
			Global::currentPipConfigClotMonWithCLLD_5mlChannels.SetAt(i, charAtIndex_6);		
		}

		return (0);
	}
		
	// Reads the number of pipetting channels as set in the instrument (Masterboard). 
	static function getNumberOfChannels(device& ML_STAR)
	{
		variable rc[];
		string command;				
		string parameter;
		string result;			
		variable index;
		variable nbrOfPipChn;
		
		command = "C0RM";
		parameter = "";			

		rc = FirmwareCommand::Execute(ML_STAR, command, parameter);
		result = rc.GetAt(rc.GetSize() - 1);

		//Check for firmware error
		FirmwareError::ErrorCheck(result);

		index = result.Find("kp");
		nbrOfPipChn = result.Mid((index+2), 2);

		// trim leading zeros, otherwise the number will be interpreted octal
		StrTrimLeft(nbrOfPipChn, "0");
		Global::numberOfChannels = IVal(nbrOfPipChn);
		
		#ifdef _DEBUG
		Trace("Number of pipetting channels: ", Global::numberOfChannels);
		#endif

		return (0);
	}

	// Reads the number of pipetting channels as set in the instrument (Masterboard). 
	static function getNumberOf_5mlChannels(device& ML_STAR)
	{
		variable rc[];
		string command;
		string parameter;
		string result;	
		variable index;
		variable nbrOfPipChn;
		
		command = "C0QM";
		parameter = "";			

		rc = FirmwareCommand::Execute(ML_STAR, command, parameter);
		result = rc.GetAt(rc.GetSize() - 1);

		//Check for firmware error
		FirmwareError::ErrorCheck(result);

		index = result.Find("kc");
		nbrOfPipChn = result.Mid((index+2), 1);

		// trim leading zeros, otherwise the number will be interpreted octal
		Global::numberOf_5mlChannels = IVal(nbrOfPipChn);
		
		#ifdef _DEBUG
		Trace("Number of pipetting channels: ", Global::numberOf_5mlChannels);
		#endif

		return (0);
	}

	// --------------------------------------------------------------------------------------
	// Interface function Aspiration and clot detection monitoring with
	// the pLLD ON
	// --------------------------------------------------------------------------------------

	function AspirationMonitoring_1000ulChannel_On(device& ML_STAR) void
	{
		variable i;	
		variable command("");
		variable parameter("");
		variable rc[];
		string result;										// result string from firmware
		variable traceSource;							// source for formated trace
		variable traceAction;							// action for formated trace
		variable traceError;								// error for formated trace

		// initialize HSLML_STAR library
		InitHSLML_STARLibrary(ML_STAR);
	
		traceSource = StringTable::Load(HSLML_STAR::IDS::traceSource);
		traceAction = StringTable::Load(HSLML_STAR::IDS::traceActionAspirationMonitoringOn);

		// Trace start of AspirationMonitoringOn	
		FormatTrace(traceSource, traceAction, 1); 

		getCurrentPipettingConfiguration(ML_STAR);

		for (i = 0; i < Global::numberOfChannels; i++)
		{
			command = Global::channel.GetAt(i) + "AA";	//first channel is P1
			parameter = "au"
							+ Global::currentPipConfigOfTipRecognition.GetAt(i)
							+ " "
							+ "1"
							+ " "
							+ Global::currentPipConfigAspMonWithCLLD.GetAt(i)
							+ " "
							+ Global::currentPipConfigClotMonWithCLLD.GetAt(i);

			#ifdef _DEBUG
			Trace(command, parameter, ".");
			#endif

			if ( IsSimulatorMode(ML_STAR) )
			{
				variable strSimMode;
				strSimMode = StringTable::Load(HSLML_STAR::IDS::simulatorModeFirmwrCmdNotExecuted);
				strSimMode = strSimMode + "'" + command + "' ; '" + parameter + "'";
				FormatTrace(ML_STAR.GetInstrumentName(), strSimMode, 4); 
			}
			else
			{
				rc = FirmwareCommand::Execute(ML_STAR, command, parameter);
				result = rc.GetAt(rc.GetSize() - 1);
	
				//Check for firmware error
				FirmwareError::ErrorCheck(result);
			}
		}

		// Trace end of AspirationMonitoringOn	
		FormatTrace(traceSource, traceAction, 2);
		
		return;
	}

	static function AspirationMonitoringOn(device& ML_STAR) void
	{
		// just forward to new named function
		AspirationMonitoring_1000ulChannel_On(ML_STAR);
	}

	function AspirationMonitoring_5mlChannel_On(device& ML_STAR) void
	{
		variable i;	
		variable command("");
		variable parameter("");
		variable rc[];
		string result;										// result string from firmware
		variable traceSource;							// source for formated trace
		variable traceAction;							// action for formated trace
		variable traceError;								// error for formated trace

		// initialize HSLML_STAR library
		InitHSLML_STARLibrary(ML_STAR);
	
		traceSource = StringTable::Load(HSLML_STAR::IDS::traceSource);
		traceAction = StringTable::Load(HSLML_STAR::IDS::traceActionAspMonitoring_5ml_On);

		// Trace start of AspirationMonitoringOn	
		FormatTrace(traceSource, traceAction, 1); 

		getCurrentPipettingConfiguration_5mlChannels(ML_STAR);

		for (i = 0; i < Global::numberOf_5mlChannels; i++)
		{
			command = Global::channelNode_5ml.GetAt(i) + "AA";	//first channel is L1
			parameter = "au"
							+ Global::currentPipConfigOfTipRecognition_5mlChannels.GetAt(i)
							+ " "
							+ "1"
							+ " "
							+ Global::currentPipConfigAspMonWithCLLD_5mlChannels.GetAt(i)
							+ " "
							+ Global::currentPipConfigClotMonWithCLLD_5mlChannels.GetAt(i);

			#ifdef _DEBUG
			Trace(command, parameter, ".");
			#endif

			if ( IsSimulatorMode(ML_STAR) )
			{
				variable strSimMode;
				strSimMode = StringTable::Load(HSLML_STAR::IDS::simulatorModeFirmwrCmdNotExecuted);
				strSimMode = strSimMode + "'" + command + "' ; '" + parameter + "'";
				FormatTrace(ML_STAR.GetInstrumentName(), strSimMode, 4); 
			}
			else
			{
				rc = FirmwareCommand::Execute(ML_STAR, command, parameter);
				result = rc.GetAt(rc.GetSize() - 1);
	
				//Check for firmware error
				FirmwareError::ErrorCheck(result);
			}
		}

		// Trace end of AspirationMonitoringOn	
		FormatTrace(traceSource, traceAction, 2);
		
		return;
	}


	// --------------------------------------------------------------------------------------
	// Interface function Aspiration and clot detection monitoring with
	// the pLLD OFF
	// --------------------------------------------------------------------------------------

	function AspirationMonitoring_1000ulChannel_Off(device& ML_STAR) void
	{
		variable i;	
		variable command("");
		variable parameter("");
		variable rc[];
		string result;										// result string from firmware
		variable traceSource;							// source for formated trace
		variable traceAction;							// action for formated trace
		variable traceError;								// error for formated trace

		// initialize HSLML_STAR library
		InitHSLML_STARLibrary(ML_STAR);
	
		traceSource = StringTable::Load(HSLML_STAR::IDS::traceSource);
		traceAction = StringTable::Load(HSLML_STAR::IDS::traceActionAspirationMonitoringOff);

		// Trace start of AspirationMonitoringOff	
		FormatTrace(traceSource, traceAction, 1); 

		getCurrentPipettingConfiguration(ML_STAR);

		for (i = 0; i < Global::numberOfChannels; i++)
		{
			command = Global::channel.GetAt(i) + "AA";	//first channel is P1
			parameter = "au"
							+ Global::currentPipConfigOfTipRecognition.GetAt(i)
							+ " "
							+ "0"
							+ " "
							+ Global::currentPipConfigAspMonWithCLLD.GetAt(i)
							+ " "
							+ Global::currentPipConfigClotMonWithCLLD.GetAt(i);
			
			#ifdef _DEBUG
			Trace(command, parameter);
			#endif

			if ( IsSimulatorMode(ML_STAR) )
			{
				variable strSimMode;
				strSimMode = StringTable::Load(HSLML_STAR::IDS::simulatorModeFirmwrCmdNotExecuted);
				strSimMode = strSimMode + "'" + command + "' ; '" + parameter + "'";
				FormatTrace(ML_STAR.GetInstrumentName(), strSimMode, 4); 
			}
			else
			{
				rc = FirmwareCommand::Execute(ML_STAR, command, parameter);
				result = rc.GetAt(rc.GetSize() - 1);
	
				// Check for firmware error
				FirmwareError::ErrorCheck(result);
			}
		}

		// Trace end of AspirationMonitoringOff	
		FormatTrace(traceSource, traceAction, 2);
		
		return; 
	}

	static function AspirationMonitoringOff(device& ML_STAR) void
	{
		// just forward to new named function
		AspirationMonitoring_1000ulChannel_Off(ML_STAR);
	}

	function AspirationMonitoring_5mlChannel_Off(device& ML_STAR) void
	{
		variable i;	
		variable command("");
		variable parameter("");
		variable rc[];
		string result;										// result string from firmware
		variable traceSource;							// source for formated trace
		variable traceAction;							// action for formated trace
		variable traceError;								// error for formated trace

		// initialize HSLML_STAR library
		InitHSLML_STARLibrary(ML_STAR);
	
		traceSource = StringTable::Load(HSLML_STAR::IDS::traceSource);
		traceAction = StringTable::Load(HSLML_STAR::IDS::traceActionAspMonitoring_5ml_Off);

		// Trace start of AspirationMonitoringOff	
		FormatTrace(traceSource, traceAction, 1); 

		getCurrentPipettingConfiguration_5mlChannels(ML_STAR);

		for (i = 0; i < Global::numberOf_5mlChannels; i++)
		{
			command = Global::channelNode_5ml.GetAt(i) + "AA";	//first channel is L1
			parameter = "au"
							+ Global::currentPipConfigOfTipRecognition_5mlChannels.GetAt(i)
							+ " "
							+ "0"
							+ " "
							+ Global::currentPipConfigAspMonWithCLLD_5mlChannels.GetAt(i)
							+ " "
							+ Global::currentPipConfigClotMonWithCLLD_5mlChannels.GetAt(i);
			
			#ifdef _DEBUG
			Trace(command, parameter);
			#endif

			if ( IsSimulatorMode(ML_STAR) )
			{
				variable strSimMode;
				strSimMode = StringTable::Load(HSLML_STAR::IDS::simulatorModeFirmwrCmdNotExecuted);
				strSimMode = strSimMode + "'" + command + "' ; '" + parameter + "'";
				FormatTrace(ML_STAR.GetInstrumentName(), strSimMode, 4); 
			}
			else
			{
				rc = FirmwareCommand::Execute(ML_STAR, command, parameter);
				result = rc.GetAt(rc.GetSize() - 1);
	
				// Check for firmware error
				FirmwareError::ErrorCheck(result);
			}
		}

		// Trace end of AspirationMonitoringOff	
		FormatTrace(traceSource, traceAction, 2);
		
		return; 
	}

	// --------------------------------------------------------------------------------------
	// Interface function Clot detection monitoring with the cLLD ON
	// --------------------------------------------------------------------------------------

	function ClotDetectionMonitoring_1000ulChannel_On(device& ML_STAR) void
	{
		variable i;	
		variable command("");
		variable parameter("");
		variable rc[];
		string result;										// result string from firmware
		variable traceSource;							// source for formated trace
		variable traceAction;							// action for formated trace
		variable traceError;								// error for formated trace

		// initialize HSLML_STAR library
		InitHSLML_STARLibrary(ML_STAR);
	
		traceSource = StringTable::Load(HSLML_STAR::IDS::traceSource);
		traceAction = StringTable::Load(HSLML_STAR::IDS::traceActionClotDetectionMonitoringOn);

		// Trace start of ClotDetectionMonitoringOn	
		FormatTrace(traceSource, traceAction, 1); 

		getCurrentPipettingConfiguration(ML_STAR);

		for (i = 0; i < Global::numberOfChannels; i++)
		{
			command = Global::channel.GetAt(i) + "AA";
			parameter = "au"
							+ Global::currentPipConfigOfTipRecognition.GetAt(i)
							+ " " 
							+ Global::currentPipConfigAspMonWithPLLD.GetAt(i)
							+ " "
							+ Global::currentPipConfigAspMonWithCLLD.GetAt(i)
							+ " "
							+ "1";

			#ifdef _DEBUG
			Trace(command, parameter);
			#endif

			if ( IsSimulatorMode(ML_STAR) )
			{
				variable strSimMode;
				strSimMode = StringTable::Load(HSLML_STAR::IDS::simulatorModeFirmwrCmdNotExecuted);
				strSimMode = strSimMode + "'" + command + "' ; '" + parameter + "'";
				FormatTrace(ML_STAR.GetInstrumentName(), strSimMode, 4); 
			}
			else
			{
				rc = FirmwareCommand::Execute(ML_STAR, command, parameter);
				result = rc.GetAt(rc.GetSize() - 1);
	
				// Check for firmware error
				FirmwareError::ErrorCheck(result);
			}
		}
		// Trace end of ClotDetectionMonitoringOn	
		FormatTrace(traceSource, traceAction, 2);

		return;
	}

	static function ClotDetectionMonitoringOn(device& ML_STAR) void
	{
		// just forward to new named function
		ClotDetectionMonitoring_1000ulChannel_On(ML_STAR);
	}

	function ClotDetectionMonitoring_5mlChannel_On(device& ML_STAR) void
	{
		variable i;	
		variable command("");
		variable parameter("");
		variable rc[];
		string result;										// result string from firmware
		variable traceSource;							// source for formated trace
		variable traceAction;							// action for formated trace
		variable traceError;								// error for formated trace

		// initialize HSLML_STAR library
		InitHSLML_STARLibrary(ML_STAR);
	
		traceSource = StringTable::Load(HSLML_STAR::IDS::traceSource);
		traceAction = StringTable::Load(HSLML_STAR::IDS::traceActionClotDetMonitoring_5ml_On);

		// Trace start of ClotDetectionMonitoringOn	
		FormatTrace(traceSource, traceAction, 1); 

		getCurrentPipettingConfiguration_5mlChannels(ML_STAR);

		for (i = 0; i < Global::numberOf_5mlChannels; i++)
		{
			command = Global::channelNode_5ml.GetAt(i) + "AA";
			parameter = "au"
							+ Global::currentPipConfigOfTipRecognition_5mlChannels.GetAt(i)
							+ " " 
							+ Global::currentPipConfigAspMonWithPLLD_5mlChannels.GetAt(i)
							+ " "
							+ Global::currentPipConfigAspMonWithCLLD_5mlChannels.GetAt(i)
							+ " "
							+ "1";

			#ifdef _DEBUG
			Trace(command, parameter);
			#endif

			if ( IsSimulatorMode(ML_STAR) )
			{
				variable strSimMode;
				strSimMode = StringTable::Load(HSLML_STAR::IDS::simulatorModeFirmwrCmdNotExecuted);
				strSimMode = strSimMode + "'" + command + "' ; '" + parameter + "'";
				FormatTrace(ML_STAR.GetInstrumentName(), strSimMode, 4); 
			}
			else
			{
				rc = FirmwareCommand::Execute(ML_STAR, command, parameter);
				result = rc.GetAt(rc.GetSize() - 1);
	
				// Check for firmware error
				FirmwareError::ErrorCheck(result);
			}
		}
		// Trace end of ClotDetectionMonitoringOn	
		FormatTrace(traceSource, traceAction, 2);

		return;
	}

	// --------------------------------------------------------------------------------------
	// Interface function Clot detection monitoring with the cLLD OFF
	// --------------------------------------------------------------------------------------

	function ClotDetectionMonitoring_1000ulChannel_Off(device& ML_STAR) void
	{
		variable i;	
		variable command("");
		variable parameter("");
		variable rc[];
		string result;										// result string from firmware
		variable traceSource;							// source for formated trace
		variable traceAction;							// action for formated trace
		variable traceError;								// error for formated trace

		// initialize HSLML_STAR library
		InitHSLML_STARLibrary(ML_STAR);
	
		traceSource = StringTable::Load(HSLML_STAR::IDS::traceSource);
		traceAction = StringTable::Load(HSLML_STAR::IDS::traceActionClotDetectionMonitoringOff);

		// Trace start of ClotDetectionMonitoringOff	
		FormatTrace(traceSource, traceAction, 1); 

		getCurrentPipettingConfiguration(ML_STAR);

		for (i = 0; i < Global::numberOfChannels; i++)
		{
			command = Global::channel.GetAt(i) + "AA";
			parameter = "au"
							+ Global::currentPipConfigOfTipRecognition.GetAt(i)
							+ " " 
							+ Global::currentPipConfigAspMonWithPLLD.GetAt(i)
							+ " "
							+ Global::currentPipConfigAspMonWithCLLD.GetAt(i)
							+ " "
							+ "0";

			#ifdef _DEBUG
			Trace(command, parameter);
			#endif

			if ( IsSimulatorMode(ML_STAR) )
			{
				variable strSimMode;
				strSimMode = StringTable::Load(HSLML_STAR::IDS::simulatorModeFirmwrCmdNotExecuted);
				strSimMode = strSimMode + "'" + command + "' ; '" + parameter + "'";
				FormatTrace(ML_STAR.GetInstrumentName(), strSimMode, 4); 
			}
			else
			{
				rc = FirmwareCommand::Execute(ML_STAR, command, parameter);
				result = rc.GetAt(rc.GetSize() - 1);
	
				// Check for firmware error
				FirmwareError::ErrorCheck(result);
			}
		}

		// Trace end of ClotDetectionMonitoringOff	
		FormatTrace(traceSource, traceAction, 2);

		return;
	}

	static function ClotDetectionMonitoringOff(device& ML_STAR) void
	{
		// just forward to new named function
		ClotDetectionMonitoring_1000ulChannel_Off(ML_STAR);
	}

	function ClotDetectionMonitoring_5mlChannel_Off(device& ML_STAR) void
	{
		variable i;	
		variable command("");
		variable parameter("");
		variable rc[];
		string result;										// result string from firmware
		variable traceSource;							// source for formated trace
		variable traceAction;							// action for formated trace
		variable traceError;								// error for formated trace

		// initialize HSLML_STAR library
		InitHSLML_STARLibrary(ML_STAR);
	
		traceSource = StringTable::Load(HSLML_STAR::IDS::traceSource);
		traceAction = StringTable::Load(HSLML_STAR::IDS::traceActionClotDetMonitoring_5ml_Off);

		// Trace start of ClotDetectionMonitoringOff	
		FormatTrace(traceSource, traceAction, 1); 

		getCurrentPipettingConfiguration_5mlChannels(ML_STAR);

		for (i = 0; i < Global::numberOf_5mlChannels; i++)
		{
			command = Global::channelNode_5ml.GetAt(i) + "AA";
			parameter = "au"
							+ Global::currentPipConfigOfTipRecognition_5mlChannels.GetAt(i)
							+ " " 
							+ Global::currentPipConfigAspMonWithPLLD_5mlChannels.GetAt(i)
							+ " "
							+ Global::currentPipConfigAspMonWithCLLD_5mlChannels.GetAt(i)
							+ " "
							+ "0";

			#ifdef _DEBUG
			Trace(command, parameter);
			#endif

			if ( IsSimulatorMode(ML_STAR) )
			{
				variable strSimMode;
				strSimMode = StringTable::Load(HSLML_STAR::IDS::simulatorModeFirmwrCmdNotExecuted);
				strSimMode = strSimMode + "'" + command + "' ; '" + parameter + "'";
				FormatTrace(ML_STAR.GetInstrumentName(), strSimMode, 4); 
			}
			else
			{
				rc = FirmwareCommand::Execute(ML_STAR, command, parameter);
				result = rc.GetAt(rc.GetSize() - 1);
	
				// Check for firmware error
				FirmwareError::ErrorCheck(result);
			}
		}

		// Trace end of ClotDetectionMonitoringOff	
		FormatTrace(traceSource, traceAction, 2);

		return;
	}

	// --------------------------------------------------------------------------------------
	// Interface function to activate Anti Droplet Control.
	// --------------------------------------------------------------------------------------

	function AntiDropletControl_1000ulChannel_On(
		device& ML_STAR) void
	{
		variable i(0);										// Loop counter
		variable command("");							// Firmaware command
		variable parameter("");							// Firmaware command parameters
		variable rc[];										// Firmaware command results
		variable result("");								// Result string from firmware
		variable traceSource;							// Source for formated trace
		variable traceAction;							// Action for formated trace

		// initialize HSLML_STAR library
		InitHSLML_STARLibraryCore();
	
		traceSource = StringTable::Load(HSLML_STAR::IDS::traceSource);
		traceAction = StringTable::Load(HSLML_STAR::IDS::traceActionAntiDropletControlOn);

		// Trace start of AntiDropletControlOn
		FormatTrace(traceSource, traceAction, 1); 

		// Activate ADC
		command = "PXAA";
		parameter = "bl1";

		#ifdef _DEBUG
		Trace(command, parameter);
		#endif

		if ( IsSimulatorMode(ML_STAR) )
		{
			variable strSimMode("");
			strSimMode = StringTable::Load(HSLML_STAR::IDS::simulatorModeFirmwrCmdNotExecuted);
			strSimMode = strSimMode + "'" + command + "' ; '" + parameter + "'";
			FormatTrace(ML_STAR.GetInstrumentName(), strSimMode, 4); 
		}
		else
		{
			rc = FirmwareCommand::Execute(ML_STAR, command, parameter);
			result = rc.GetAt(rc.GetSize() - 1);

			// Check for firmware error
			FirmwareError::ErrorCheck2(command + parameter, result);
		}

		// Trace end of AntiDropletControlOn
		FormatTrace(traceSource, traceAction, 2);

		return;
	}

	static function AntiDropletControlOn(device& ML_STAR) void
	{
		// just forward to new named function
		AntiDropletControl_1000ulChannel_On(ML_STAR);
	}

	function AntiDropletControl_5mlChannel_On(
		device& ML_STAR) void
	{
		variable i(0);										// Loop counter
		variable command("");							// Firmaware command
		variable parameter("");							// Firmaware command parameters
		variable rc[];										// Firmaware command results
		variable result("");								// Result string from firmware
		variable traceSource;							// Source for formated trace
		variable traceAction;							// Action for formated trace

		// initialize HSLML_STAR library
		InitHSLML_STARLibraryCore();
	
		traceSource = StringTable::Load(HSLML_STAR::IDS::traceSource);
		traceAction = StringTable::Load(HSLML_STAR::IDS::traceActionADC_5ml_On);

		// Trace start of AntiDropletControlOn
		FormatTrace(traceSource, traceAction, 1); 

		// Activate ADC on 5ml channels
		command = "LXAA";
		parameter = "bl1";

		#ifdef _DEBUG
		Trace(command, parameter);
		#endif

		if ( IsSimulatorMode(ML_STAR) )
		{
			variable strSimMode("");
			strSimMode = StringTable::Load(HSLML_STAR::IDS::simulatorModeFirmwrCmdNotExecuted);
			strSimMode = strSimMode + "'" + command + "' ; '" + parameter + "'";
			FormatTrace(ML_STAR.GetInstrumentName(), strSimMode, 4); 
		}
		else
		{
			rc = FirmwareCommand::Execute(ML_STAR, command, parameter);
			result = rc.GetAt(rc.GetSize() - 1);

			// Check for firmware error
			FirmwareError::ErrorCheck2(command + parameter, result);
		}

		// Trace end of AntiDropletControlOn
		FormatTrace(traceSource, traceAction, 2);

		return;
	}

	// --------------------------------------------------------------------------------------
	// Interface function to deactivate Anti Droplet Control.
	// --------------------------------------------------------------------------------------

	function AntiDropletControl_1000ulChannel_Off(
		device& ML_STAR) void
	{
		variable i(0);										// Loop counter
		variable command("");							// Firmaware command
		variable parameter("");							// Firmaware command parameters
		variable rc[];										// Firmaware command results
		variable result("");								// Result string from firmware
		variable traceSource;							// Source for formated trace
		variable traceAction;							// Action for formated trace

		// initialize HSLML_STAR library
		InitHSLML_STARLibraryCore();
	
		traceSource = StringTable::Load(HSLML_STAR::IDS::traceSource);
		traceAction = StringTable::Load(HSLML_STAR::IDS::traceActionAntiDropletControlOff);

		// Trace start of AntiDropletControlOff
		FormatTrace(traceSource, traceAction, 1); 

		// Deactivate ADC
		command = "PXAA";
		parameter = "bl0";

		#ifdef _DEBUG
		Trace(command, parameter);
		#endif

		if ( IsSimulatorMode(ML_STAR) )
		{
			variable strSimMode("");
			strSimMode = StringTable::Load(HSLML_STAR::IDS::simulatorModeFirmwrCmdNotExecuted);
			strSimMode = strSimMode + "'" + command + "' ; '" + parameter + "'";
			FormatTrace(ML_STAR.GetInstrumentName(), strSimMode, 4); 
		}
		else
		{
			rc = FirmwareCommand::Execute(ML_STAR, command, parameter);
			result = rc.GetAt(rc.GetSize() - 1);

			// Check for firmware error
			FirmwareError::ErrorCheck2(command + parameter, result);
		}

		// Trace end of AntiDropletControlOff
		FormatTrace(traceSource, traceAction, 2);

		return;
	}

	static function AntiDropletControlOff(device& ML_STAR) void
	{
		// just forward to new named function
		AntiDropletControl_1000ulChannel_Off(ML_STAR);
	}

	function AntiDropletControl_5mlChannel_Off(
		device& ML_STAR) void
	{
		variable i(0);										// Loop counter
		variable command("");							// Firmaware command
		variable parameter("");							// Firmaware command parameters
		variable rc[];										// Firmaware command results
		variable result("");								// Result string from firmware
		variable traceSource;							// Source for formated trace
		variable traceAction;							// Action for formated trace

		// initialize HSLML_STAR library
		InitHSLML_STARLibraryCore();
	
		traceSource = StringTable::Load(HSLML_STAR::IDS::traceSource);
		traceAction = StringTable::Load(HSLML_STAR::IDS::traceActionADC_5ml_Off);

		// Trace start of AntiDropletControlOff
		FormatTrace(traceSource, traceAction, 1); 

		// Deactivate ADC on 5ml channels
		command = "LXAA";
		parameter = "bl0";

		#ifdef _DEBUG
		Trace(command, parameter);
		#endif

		if ( IsSimulatorMode(ML_STAR) )
		{
			variable strSimMode("");
			strSimMode = StringTable::Load(HSLML_STAR::IDS::simulatorModeFirmwrCmdNotExecuted);
			strSimMode = strSimMode + "'" + command + "' ; '" + parameter + "'";
			FormatTrace(ML_STAR.GetInstrumentName(), strSimMode, 4); 
		}
		else
		{
			rc = FirmwareCommand::Execute(ML_STAR, command, parameter);
			result = rc.GetAt(rc.GetSize() - 1);

			// Check for firmware error
			FirmwareError::ErrorCheck2(command + parameter, result);
		}

		// Trace end of AntiDropletControlOff
		FormatTrace(traceSource, traceAction, 2);

		return;
	}

	// --------------------------------------------------------------------------------------
	// Interface function Set the pressure threshold for clot detection
	// with the cLLD 
	// --------------------------------------------------------------------------------------

	function SetPressureThreshold_1000ulChannel(device& ML_STAR, variable pressure) void
	{
		variable i;	
		variable command("");
		variable parameter("");
		variable rc[];
		string result;										// result string from firmware
		variable traceSource;							// source for formated trace
		variable traceAction;							// action for formated trace
		variable traceError;								// error for formated trace
		variable message;
		string str;

		// initialize HSLML_STAR library
		InitHSLML_STARLibrary(ML_STAR);
	
		traceSource = StringTable::Load(HSLML_STAR::IDS::traceSource);
		traceAction = StringTable::Load(HSLML_STAR::IDS::traceActionSetPressureThreshold);

		// Trace start of SetPressureThreshold	
		FormatTrace(traceSource, traceAction, 1);

		//Parameter check of variable pressure (must be Integer)
		if( Util::IsString(pressure) || Util::IsFloat(pressure))
		{
			message = StringTable::Load(HSLML_STAR::IDE::invalidParameterType);
			MessageBox( message, StringTable::Load(HSLML_STAR::IDE::invalidParameterTitle) + traceAction, hslOKOnly | hslError );
			FormatTrace(traceSource, traceAction, 5); 
			abort;
		}

		//Parameter check of variable pressure (range is 0..1023)
		if((pressure < 0) || (pressure > 1023))
		{
			message = StringTable::Load(HSLML_STAR::IDE::invalidParameterRange);
			MessageBox( message, StringTable::Load(HSLML_STAR::IDE::invalidParameterTitle) + traceAction, hslOKOnly | hslError );
			FormatTrace(traceSource, traceAction, 5); 
			abort;
		}

		str = IStr(pressure);
	
		// add leading zeros if the value has less than four characters
		if(str.GetLength() < 4)
		{
			Util::FillLeft(str , "0", 4);
		}
		
		//add sign to string
		Util::FillLeft(str , "+", 5);

		parameter = str;

		command = "PXAA";

		parameter = "kc" + parameter;

		#ifdef _DEBUG
		Trace(command, parameter);
		#endif

		if ( IsSimulatorMode(ML_STAR) )
		{
			variable strSimMode;
			strSimMode = StringTable::Load(HSLML_STAR::IDS::simulatorModeFirmwrCmdNotExecuted);
			strSimMode = strSimMode + "'" + command + "' ; '" + parameter + "'";
			FormatTrace(ML_STAR.GetInstrumentName(), strSimMode, 4); 
		}
		else
		{
			rc = FirmwareCommand::Execute(ML_STAR, command, parameter);
			result = rc.GetAt(rc.GetSize() - 1);
	
			// Check for firmware error
			FirmwareError::ErrorCheck(result);
		}
	
		// Trace end of SetPressureThreshold	
		FormatTrace(traceSource, traceAction, 2); 

		return;
	}

	static function SetPressureThreshold(device& ML_STAR, variable pressure) void
	{
		// just forward to new named function
		SetPressureThreshold_1000ulChannel(ML_STAR, pressure);
	}

	function SetPressureThreshold_5mlChannel(device& ML_STAR, variable pressure) void
	{
		variable i;	
		variable command("");
		variable parameter("");
		variable rc[];
		string result;										// result string from firmware
		variable traceSource;							// source for formated trace
		variable traceAction;							// action for formated trace
		variable traceError;								// error for formated trace
		variable message;
		string str;

		// initialize HSLML_STAR library
		InitHSLML_STARLibrary(ML_STAR);
	
		traceSource = StringTable::Load(HSLML_STAR::IDS::traceSource);
		traceAction = StringTable::Load(HSLML_STAR::IDS::traceActionSetPressureThreshold_5ml);

		// Trace start of SetPressureThreshold	
		FormatTrace(traceSource, traceAction, 1);

		//Parameter check of variable pressure (must be Integer)
		if( Util::IsString(pressure) || Util::IsFloat(pressure))
		{
			message = StringTable::Load(HSLML_STAR::IDE::invalidParameterType);
			MessageBox( message, StringTable::Load(HSLML_STAR::IDE::invalidParameterTitle) + traceAction, hslOKOnly | hslError );
			FormatTrace(traceSource, traceAction, 5); 
			abort;
		}

		//Parameter check of variable pressure (range is 0..1023)
		if((pressure < 0) || (pressure > 1023))
		{
			message = StringTable::Load(HSLML_STAR::IDE::invalidParameterRange);
			MessageBox( message, StringTable::Load(HSLML_STAR::IDE::invalidParameterTitle) + traceAction, hslOKOnly | hslError );
			FormatTrace(traceSource, traceAction, 5); 
			abort;
		}

		str = IStr(pressure);
	
		// add leading zeros if the value has less than four characters
		if(str.GetLength() < 4)
		{
			Util::FillLeft(str , "0", 4);
		}
		
		//add sign to string
		Util::FillLeft(str , "+", 5);

		parameter = str;

		command = "LXAA";

		parameter = "kc" + parameter;

		#ifdef _DEBUG
		Trace(command, parameter);
		#endif

		if ( IsSimulatorMode(ML_STAR) )
		{
			variable strSimMode;
			strSimMode = StringTable::Load(HSLML_STAR::IDS::simulatorModeFirmwrCmdNotExecuted);
			strSimMode = strSimMode + "'" + command + "' ; '" + parameter + "'";
			FormatTrace(ML_STAR.GetInstrumentName(), strSimMode, 4); 
		}
		else
		{
			rc = FirmwareCommand::Execute(ML_STAR, command, parameter);
			result = rc.GetAt(rc.GetSize() - 1);
	
			// Check for firmware error
			FirmwareError::ErrorCheck(result);
		}
	
		// Trace end of SetPressureThreshold	
		FormatTrace(traceSource, traceAction, 2); 

		return;
	}

	// --------------------------------------------------------------------------------------
	// Interface function to set barcode types.
	// --------------------------------------------------------------------------------------

	function SetBarcodeTypes(
		device& ML_STAR, 
		variable& barcodeTypes) void
	{
		variable i(0);
		variable command("");							// Firmaware command
		variable parameter("");							// Firmaware command parameters
		variable rc[];										// Firmaware command results
		variable result("");								// Result string from firmware
		variable traceSource;							// Source for formated trace
		variable traceAction;							// Action for formated trace
		variable errorDesc("");							// Error description
		variable barcodeTypesCopy("");				// Copy of param barcodeTypes

		// Constants for barcode types, see 'Command Specification for Master Module'
		variable ISBT_Standard(1);
		variable Code_128(2);
		variable Code_39(4);
		variable Codabar(8);
		variable Code_2_of_5_Interleaved(16);
		variable UPC_A_E(32);
		variable JAN_EAN_8(64);

		variable numberOfSupportedBarcodeTypes(7);

		// initialize HSLML_STAR library
		InitHSLML_STARLibraryCore();
	
		traceSource = StringTable::Load(HSLML_STAR::IDS::traceSource);
		traceAction = StringTable::Load(HSLML_STAR::IDS::traceActionSetBarcodeTypes);

		// Trace start of SetBarcodeTypes
		FormatTrace(traceSource, traceAction, 1); 

		// Activate error handler
		onerror goto Unexpected;

		// Check input params to be valid.
		errorDesc = traceAction + "\n";
		Util2::CheckValueTypeAndRangeMinMax(barcodeTypes, hslString, 0, numberOfSupportedBarcodeTypes, errorDesc + "barcodeTypes");

		// Build parameter string
		parameter = 0;
		barcodeTypesCopy = barcodeTypes;
		StrFillRight(barcodeTypesCopy, "1", numberOfSupportedBarcodeTypes);
		for (i = 0; i < numberOfSupportedBarcodeTypes; i++)
		{
			variable c("");

			c = StrMid(barcodeTypesCopy, i, 1);
			if ("0" != c && "1" != c)
			{
				Error::Raise(IDE::invalidBarcodeTypesString, GetFileName(), GetFunctionName(), GetLineNumber());
			}

			if ("1" == c)
			{
				if (0 == i)
				{
					parameter = parameter | ISBT_Standard;
				}
				else if (1 == i)
				{
					parameter = parameter | Code_128;
				}
				else if (2 == i)
				{
					parameter = parameter | Code_39;
				}
				else if (3 == i)
				{
					parameter = parameter | Codabar;
				}
				else if (4 == i)
				{
					parameter = parameter | Code_2_of_5_Interleaved;
				}
				else if (5 == i)
				{
					parameter = parameter | UPC_A_E;
				}
				else if (6 == i)
				{
					parameter = parameter | JAN_EAN_8;
				}
			}
		}
		parameter = StrHexIStr(parameter);
		parameter = StrRight(parameter, 2);
		StrMakeUpper(parameter);

		// Set barcode types
		command = "C0CB";
		parameter = "bt" + parameter;

		#ifdef _DEBUG
		Trace(command, parameter);
		#endif

		rc = FirmwareCommand::Execute(ML_STAR, command, parameter);
		result = rc.GetAt(rc.GetSize() - 1);

		// Check for firmware error
		FirmwareError::ErrorCheck2(command + parameter, result);

		// Trace end of AntiDropletControlOff
		FormatTrace(traceSource, traceAction, 2);

		return;

		Unexpected:
 		{
			// Trace completion with error of function
			FormatTrace(traceSource, traceAction, 5);

			// Re-throw the error 
			Util2::Error::RaiseLast();
		}
	}

   // --------------------------------------------------------------------------------------
   // Interface function to Create an AT Barcode file 
   // --------------------------------------------------------------------------------------

   function CreateATBarcodefile (device& ml_star, variable& Labware_id_Plate) variable
   {
	   variable Path;								// Pathname to call the HxAtfilter program with all Parameters
	   variable methodName;
	   variable TraceMessage;
		variable InstrumentName;
		variable TemplateNames[];
		variable LabwareNames[];
		variable Labware_id_Carrier;
		variable size;
		variable index;
		variable traceSource;					// source for formated trace
		variable traceAction;					// action for formated trace

		// initialize HSLML_STAR library
		InitHSLML_STARLibraryCore();

		traceSource = StringTable::Load(IDS::traceSource);
		traceAction = StringTable::Load(IDS::traceActionCreateATBarcodefile);

		// Trace new version of this function is in HSLReportlib
		FormatTrace( traceSource, traceAction, TraceStatus::start, StringTable::Load(IDS::traceNewFunction) );

		// Search Template name depending on the Labware_id_Plate
		ml_star.GetTemplateLabwareNames(TemplateNames, LabwareNames);
  		size = LabwareNames.GetSize();
		for (index = 0; index < size; index ++)
			if (LabwareNames.GetAt(index) == Labware_id_Plate)
				break;

      // If LabwareName exist, create AT Barcodefile
		if (index < size)
		{
		   Labware_id_Carrier = TemplateNames[index];     // Assign Template Name
			InstrumentName = ml_star.GetInstrumentName( ); // Get Instrument name
		   Path = GetMethodsPath();                       // Get Method path
		   StrReplace(Path, "Methods", "Bin");            // Replace methods with bin
		   methodName = GetMethodFileName();              // Get methode name
			//>> 20060523
			if ("" == methodName)
			{
				methodName = GetWorkflowFileName();
			}
			//<< 20060523

	      // Create path for calling HxATfilter to Create AT Barcode File, /RQ: Hidden Mode, /MN: Method Name, /PN: Plate Name  
         if (Labware_id_Carrier == "default")			  // If a plate is not on a carrier
			{
            Path = Path + "\\HxAtFilter /CY /RH \"/MN" + methodName + "\" \"/PN" + InstrumentName + "\\" + Labware_id_Plate +"\"";
				// Create trace message
				TraceMessage = StringTable::Load(IDS::tracePlate) + " " + Labware_id_Plate;
			}
         else
			{
		      Path = Path + "\\HxAtFilter /CY /RH \"/MN" + methodName + "\" \"/PN" + InstrumentName + "\\" + Labware_id_Carrier + "\\" + Labware_id_Plate +"\"";
				// Create trace message
				TraceMessage = StringTable::Load(IDS::traceCarrier) + " " + Labware_id_Carrier + "; " + 
									StringTable::Load(IDS::tracePlate) + " " + Labware_id_Plate;
			}
			// Trace start
			FormatTrace( traceSource, traceAction, TraceStatus::start, TraceMessage );

			// Call program HxATfilter with shell command
			onerror goto ShellErrorHandler;
		   if( 0 == Shell(Path, hslHide, hslSynchronous))
		   {
				// Trace error
				FormatTrace( traceSource, traceAction, TraceStatus::error_, TraceMessage );

				// Return error
				return(2);
		   }
			onerror goto 0;

			// Trace end
			FormatTrace( traceSource, traceAction, TraceStatus::complete, TraceMessage );
		}
		else
		{
		   // LabwareName doesen't exist, no Barcode file will be created
			// Trace error
			FormatTrace( traceSource, traceAction, TraceStatus::error_, StringTable::Load(IDS::traceLabwareIdNotFound) );

			// Return error
			return(1);
		}

		return(0);

		ShellErrorHandler:
		{
			// Trace error
			FormatTrace( traceSource, traceAction, TraceStatus::error_ );

			// Return error
			return(2);
		}
   }

	// --------------------------------------------------------------------------------------
	// LLD Sensitivity
	// --------------------------------------------------------------------------------------

	namespace LLDSensitivity
	{
		static const variable first(0);									// guard
		static const variable off(first);								// LLD sensitivity
		static const variable veryHigh(first + 1);					// LLD sensitivity
		static const variable high(first + 2);							// LLD sensitivity
		static const variable middle(first + 3);						// LLD sensitivity
		static const variable low(first + 4);							// LLD sensitivity
		static const variable last(first + 4);							// guard
	}

	// --------------------------------------------------------------------------------------
	// Main Error
	// --------------------------------------------------------------------------------------

	namespace MainError
	{
		static const variable noError(0);								// main error
		static const variable syntaxError(1);							// main error
		static const variable hardwareError(2);						// main error
		static const variable interruptError(3);						// main error
		static const variable clotError(4);								// main error
		static const variable noBarcodeError(5);						// main error
		static const variable insufficientError(6);					// main error
		static const variable pickUpError(7);							// main error
		static const variable noTipError(8);							// main error
		static const variable noCarrierError(9);						// main error
		static const variable executionError(10);						// main error
		static const variable lldError(11);								// main error
		static const variable noTeachInSignalError(12);				// main error
		static const variable loadingClapError(13);					// main error
		static const variable pressureError(14);						// main error
		static const variable parameterCombinationError(15);		// main error
		static const variable coverError(16);							// main error
		static const variable improperAspirationError(17);			// main error
		static const variable washerError(18);							// main error
		static const variable incubationError(19);					// main error
		static const variable lldNotFound(102);						// main error
	}

	// --------------------------------------------------------------------------------------
	// Recovery Button
	// --------------------------------------------------------------------------------------

	namespace RecoveryButton
	{
		static const variable abort_(1);									// recovery button
		static const variable cancel(2);									// recovery button
		static const variable initialize(3);							// recovery button
		static const variable repeat(4);									// recovery button
		static const variable exclude(5);								// recovery button
		static const variable waste(6);									// recovery button
		static const variable air(7);										// recovery button
		static const variable bottom(8);									// recovery button
		static const variable continue(9);								// recovery button
		static const variable barcode(10);								// recovery button
		static const variable next_(11);									// recovery button
	}

	// --------------------------------------------------------------------------------------
	// Debugging
	// --------------------------------------------------------------------------------------
	
	// The Assert function evaluates its argument.
	// In the the debug version of the pipetting library, 
	// if the result is 0, the function displays a diagnostic 
	// message and aborts the method. If the condition is nonzero, 
	// it does nothing.
	// In the the release version of the pipetting library, 
	// the function does nothing.

	static function Assert(
		variable expr,															// i: specifies a numeric expression that evaluates to nonzero or 0
		variable location)													// i: location (string or number)
	{
		#ifdef _DEBUG
		if (!expr)
		{
			variable type(GetType(location));
			if (Util::IsInteger(type))
				location = IStr(type);
			if (Util::IsFloat(type))
				location = FStr(type);
			FormatTrace("DEBUG  ", "Assert()", TraceStatus::progress, "Debug Assertion failed, Debug Error - " + location);
			MessageBox("Debug Assertion failed", "Debug Error - " + location, hslError|hslOKOnly);
			abort;
		}
		#endif
	}

	// --------------------------------------------------------------------------------------
	// Step Return 
	// --------------------------------------------------------------------------------------

	namespace StepReturn
	{
		// data (extensions to the namespace StepReturn defined in the Microlab STAR Step Return Library)

		variable copyPattern("");											// channel pattern used to execute a step during error recovery
		variable prevCopyPattern("");										// channel pattern used to execute the previous step

		namespace StepType
		{
			// Remark: The following enumeration is incomplete
			static const variable aspirate("Aspirate");				// step type
			static const variable dispense("Dispense");				// step type
			static const variable initialize("Initialize");			// step type
			static const variable tipPickup("TipPickUp");			// step type
			static const variable tipEject("TipEject");				// step type
			static const variable loadCarrier("LoadCarrier");		// step type
			static const variable unloadCarrier("UnloadCarrier");	// step type
			static const variable calibrate1536Plate("Calibrate1536Plate");// step type
			static const variable waitNeedleWashed("WaitNeedleWashed");// step type
			static const variable startNeedleWash("StartNeedleWash");// step type
			static const variable getLastLiquidLevel("GetLastLiquidLevel");	// step type
		}

		// functions (extensions to the namespace StepReturn defined in the Microlab STAR Step Return Library)

		static function Empty(												// (re)initializes the step return 
			variable& rc[]);													// i: step return 

		static function IsEmpty(											// returns true if the step return is empty
			variable& rc[]);													// i: step return 

		static function Bind(												// binds the error data to the step return 
			variable& rc[]);													// i: step return 

		static function Evaluate(											// evaluates the value returned by the steps used in the MeasureContainerVolume domaine
			device& ML_STAR,													// i: pipetting device
			variable& rc[],													// i: step return 
			variable& channelPattern);										// i: channel pattern

		static function EvaluateEx(										// evaluates the value returned by the steps used in the ExecuteWorklist domaine
			device& ML_STAR,													// i: pipetting device
			variable& rc[],													// i: step return 
			variable& channelPattern);										// i: channel pattern

		static function GetChannelPattern();							// returns the channel pattern used to execute a step during error recovery

		static function GetPrevChannelPattern();						// returns the channel pattern used to execute the previous step

		static function XorChannelPattern(								// intersects given channel pattern with the channel pattern used to execute a step during error recovery
			string& channelPattern);										// i: channel pattern

		static function IsRecovering();									// returns true if the StepReturn is recovering from an error

		static function Dump(												// dumps the step return 
			variable& rc[]);													// i: step return 

		static function DumpData();										// dumps the  internal data of the StepReturn 

		static function SetData(											// sets the internal data of the StepReturn 
			variable& stepReturn,											// i: step return
			string& channelPattern);										// i: channel pattern

		static function ResetData();										// resets the internal data of the StepReturn 

		static function HandleError(										// handles an error
			device& ML_STAR,													// i: pipetting device
			variable stepType);												// i: step type (only aspirate or getLastLiquidLevel are supported)

		static function EvaluateAspirateRecovery(						// evaluates aspirate recovery
			variable& stepReturn,											// i: step return
			string& channelPattern);										// i: channel pattern

		static function EvaluateGenericRecovery(						// generic evaluation of error recovery
			variable& stepReturn);											// i: step return
	}

	function InternalMeasureContainerVolume(
		device& ML_STAR,
		sequence& targetSequence,
		variable autoIncrement,
		variable& channelPattern,
		variable cLLDSensitivity,
		variable pLLDSensitivity,
		variable maxHeightDifference,
		variable connectedContainers) variable
	{
		variable rc[];
		variable succeeded(hslFalse);										// succeeded flag
		variable index;														// loop index
		variable length(0);													// string length
		variable traceSource("");											// source for formated trace
		variable traceAction("");											// action for formated trace
		variable maxPosBak(0);												// backup of max positions of input sequence
		variable currentPosBak(0);											// backup of current position of input sequence
		string   currentChannelPattern("");								// current channel pattern
		variable numberOfActiveChannels(0);								// number of active channels
		variable numberOfUsedPositions(0);								// number of used positions
		sequence TargetSequence;											// head of input sequence

		// activate error handler
		onerror goto Unexpected;

		// backup max and current position of input sequence
		maxPosBak = targetSequence.GetMax();
		currentPosBak = targetSequence.GetCurrentPosition();

		// initialize pipetting library
		InitHSLML_STARLibrary(ML_STAR);

		// trace start of measuring
		traceSource = StringTable::Load(IDS::traceSource);
		traceAction = StringTable::Load(IDS::traceActionMeasureContainerVolume);
		FormatTrace(traceSource, traceAction, TraceStatus::start);

		// check input parameters to be valid
		if (!Util::IsString(channelPattern))
			Error::Raise(IDE::invalidChannelPattern, GetFileName(), GetFunctionName(), GetLineNumber());
		if (StrGetLength(channelPattern) == 0)
			Error::Raise(IDE::invalidChannelPattern, GetFileName(), GetFunctionName(), GetLineNumber());
		length = StrGetLength(channelPattern);
		for (index = 0; index < length; index++)
		{
			variable character;
			character = StrMid(channelPattern, index, 1); 
			if ("1" != character && "0" != character)
				Error::Raise(IDE::invalidChannelPattern, GetFileName(), GetFunctionName(), GetLineNumber());
		}
		if (!Util::IsInteger(cLLDSensitivity))
			Error::Raise(IDE::invalidLLDSensitivity, GetFileName(), GetFunctionName(), GetLineNumber());
		if (cLLDSensitivity < LLDSensitivity::first || LLDSensitivity::last < cLLDSensitivity)
			Error::Raise(IDE::invalidLLDSensitivity, GetFileName(), GetFunctionName(), GetLineNumber());
		if (!Util::IsInteger(pLLDSensitivity))
			Error::Raise(IDE::invalidLLDSensitivity, GetFileName(), GetFunctionName(), GetLineNumber());
		if (pLLDSensitivity < LLDSensitivity::first || LLDSensitivity::last < pLLDSensitivity)
			Error::Raise(IDE::invalidLLDSensitivity, GetFileName(), GetFunctionName(), GetLineNumber());
		if (!Util::IsInteger(maxHeightDifference) && !Util::IsFloat(maxHeightDifference))
			Error::Raise(IDE::invalidMaxHeightDifference, GetFileName(), GetFunctionName(), GetLineNumber());
		if (Util::IsNegative(maxHeightDifference))
			Error::Raise(IDE::invalidMaxHeightDifference, GetFileName(), GetFunctionName(), GetLineNumber());

		// reset output 
		length = StrGetLength(channelPattern);
		Global::containerVolume.SetSize(0);
		Global::containerVolume.SetSize(length);
		for (index = 0; index < length; index++)
		{
			if ("1" == StrMid(channelPattern, index, 1))
				// channel is active, mark as failed
				Global::containerVolume.SetAt(index, 0);
			else
				// channel isn't active, mark as inactive
				Global::containerVolume.SetAt(index, -1);
		}

		if (0 == currentPosBak)
		{
			// we are done
			index = StrFind(channelPattern, "1");
			if (0 <= index)
				return(Global::containerVolume.GetAt(index));
			else
				return(-1);
		}

		// get head of input sequence
		numberOfActiveChannels = Util::NumberOfActiveChannels(channelPattern);
		for (index = currentPosBak;
			  0 < index && index <= currentPosBak + Util::Min(numberOfActiveChannels, maxPosBak) - 1;
			  index = targetSequence.Increment(1))
		{
			TargetSequence.Add(targetSequence.GetLabwareId(), targetSequence.GetPositionId());
		}
		TargetSequence.SetCount(TargetSequence.GetTotal());
		TargetSequence.SetCurrentPosition(1);
		TargetSequence.SetMax(TargetSequence.GetCount());

		// measure container volume
		if (0 < numberOfActiveChannels &&
			 0 < TargetSequence.GetCount() &&
			 (LLDSensitivity::off != cLLDSensitivity || 
			  LLDSensitivity::off != pLLDSensitivity))
		{
			for (index = 0; index < Global::maxNumberOfRetries && !succeeded; index++)
			{
				// set the channel pattern
				currentChannelPattern = StepReturn::GetPrevChannelPattern();
				if (currentChannelPattern.GetLength() == 0)
				{
					// we are not recovering from an error
					currentChannelPattern = channelPattern;
				}
				else
				{
					// we are recovering from an error
					currentChannelPattern = StepReturn::XorChannelPattern(currentChannelPattern);
				}

				Util::FillRight(currentChannelPattern, "0", Global::numberOfChannels);

				// Aspirate 0 volume 
				// Variables : TargetSequence, currentChannelPattern, cLLDSensitivity, 
				//					pLLDSensitivity, maxHeightDifference
				#ifdef _DEBUG
				FormatTrace("DEBUG  ", "ML_STAR.Aspirate", TraceStatus::progress,
								"name = ", TargetSequence.GetName(), 
								", current = ", TargetSequence.GetCurrentPosition(), 
								", count = ", TargetSequence.GetCount(),
								", maxPos = ", TargetSequence.GetMax(), 
								", currentChannelPattern = ", currentChannelPattern);
				//MessageBox("DebugBreak", "Aspirate");
				#endif
				StepReturn::Empty(rc);
				onerror goto AspirateErrorHandler;
				rc = ML_STAR.Aspirate( "f76b3bea_1e51_4db9_898f5df61564fd3a" );
				onerror goto Unexpected;

				// store the number of used positions
				if (0 == numberOfUsedPositions)
					numberOfUsedPositions = TargetSequence.GetUsedPositions();

				// evaluate step return
				if (!StepReturn::Evaluate(ML_STAR, rc, currentChannelPattern))
				{
					// failed
					variable channel(0);
					variable activeChannel(0);
					string copyPattern("");

					// handle the error
					StepReturn::HandleError(ML_STAR, StepReturn::StepType::aspirate);

					// remove positions which have been measured successfully
					copyPattern = StepReturn::GetChannelPattern();
					activeChannel = Util::NumberOfActiveChannels(currentChannelPattern);
					for (channel = length - 1; 0 <= channel; channel--)
					{
						if ("1" == currentChannelPattern.Mid(channel, 1))
						{
							if ("1" == copyPattern.Mid(channel, 1) && 
								activeChannel <= TargetSequence.GetCount())
								TargetSequence.RemoveAt(activeChannel);
							activeChannel--;
						}
					}
				}
				else
				{
					// succeeded,
					// break the loop
					succeeded = hslTrue;
				}
			}
		}
		else
		{
			// succeeded
			succeeded = hslTrue;
		}

		if (!succeeded)
		{
			// we are still recovering from an error,
			// set the channel pattern according to the channels that failed
			currentChannelPattern = StepReturn::GetPrevChannelPattern();
			if (currentChannelPattern.GetLength() == 0)
			{
				// we are not recovering from an error
				currentChannelPattern = channelPattern;
			}
			else
			{
				// we are recovering from an error
				currentChannelPattern = StepReturn::XorChannelPattern(currentChannelPattern);
			}
		}
		else
		{
			// we are not recovering from an error at all,
			// set the channel pattern according to the channels that failed
			currentChannelPattern = channelPattern;
			StrReplace(currentChannelPattern, "1", "0");
		}

		// reset data contained in StepReturn
		StepReturn::ResetData();

		// get last liquid level
		StepReturn::Empty(rc);
		onerror goto GetLastLiquidLevel;
		rc = ML_STAR.GetLastLiquidLevel( "ac5165ce_247e_45c6_9ae0cb2da102182b" );
		onerror goto Unexpected;

		// evaluate step return
		if (!StepReturn::Evaluate(ML_STAR, rc, ""))
		{
			// failed
			StepReturn::HandleError(ML_STAR, StepReturn::StepType::getLastLiquidLevel);
		}

		// set output 
		// iterate over channels
		if (2 < rc.GetSize())
		{
			variable labId("");					// labware id
			variable posId("");					// position id
			variable height(0);					// last liquid level
			variable volume(0);					// container volume
			variable stepReturn("");			// step return (string)
			variable activeChannel(0);			// active channel number

			stepReturn = rc.GetAt(2);
			for (index = 0; index < length; index++)
			{
				if ("1" == StrMid(channelPattern, index, 1))
				{
					// channel is active
					if ("0" == currentChannelPattern.Mid(index, 1))
					{
						// channel succeeded
						if (0 < targetSequence.SetCurrentPosition(currentPosBak + activeChannel))
						{
							labId = targetSequence.GetLabwareId();
							posId = targetSequence.GetPositionId();
							height = StepReturn::GetLastLiquidLevel(index + 1, stepReturn);
							volume = ML_STAR.ComputeContainerVolume(labId, posId, height, hslTrue, connectedContainers);
							Global::containerVolume.SetAt(index, volume);
							#ifdef _DEBUG
							{variable position[];
							ML_STAR.GetLabwarePosition(labId, position, posId);
							FormatTrace("DEBUG  ", "MeasureContainerVolume", TraceStatus::progress, "x-position = ", position[0]);
							FormatTrace("DEBUG  ", "MeasureContainerVolume", TraceStatus::progress, "y-position = ", position[1]);
							FormatTrace("DEBUG  ", "MeasureContainerVolume", TraceStatus::progress, "z-position = ", position[2]);}
							FormatTrace("DEBUG  ", "MeasureContainerVolume", TraceStatus::progress, "labId = ", labId);
							FormatTrace("DEBUG  ", "MeasureContainerVolume", TraceStatus::progress, "posId = ", posId);
							FormatTrace("DEBUG  ", "MeasureContainerVolume", TraceStatus::progress, "height = ", height);
							FormatTrace("DEBUG  ", "MeasureContainerVolume", TraceStatus::progress, "volume = ", volume);
							#endif
						}
					}
					// increment active channel number
					activeChannel++;
				}
			}
		}
		StepReturn::Empty(rc);

		// restore max and current position of input sequence
		targetSequence.SetMax(maxPosBak);
		targetSequence.SetCurrentPosition(currentPosBak);

		// increment input sequence if required
		if (autoIncrement)
			targetSequence.Increment(numberOfUsedPositions);

		// update number of used positions in input sequence
		targetSequence.SetUsedPositions(numberOfUsedPositions);

		// trace completion of pipetting 
		FormatTrace(traceSource, traceAction, TraceStatus::complete);

		// dump result 
		#ifdef _DEBUG
		for (index = 0; index < length; index++)
			FormatTrace("DEBUG  ", "MeasureContainerVolume", TraceStatus::progress, "containerVolume = ", Global::containerVolume.GetAt(index));
		#endif

		// return result 
		index = StrFind(channelPattern, "1");
		if (0 <= index)
			return(Global::containerVolume.GetAt(index));
		else
			return(-1);

		AspirateErrorHandler:
		{
			// bind error data
			StepReturn::Bind(rc);
			resume next;
		}

		GetLastLiquidLevel:
		{
			// bind error data
			StepReturn::Bind(rc);
			resume next;
		}

		Unexpected:
		{

			// reset output 
			Global::containerVolume.SetSize(0);

			// restore max and current position of input sequence
			targetSequence.SetMax(maxPosBak);
			targetSequence.SetCurrentPosition(currentPosBak);

			// trace completion with error of pipetting 
			FormatTrace(traceSource, traceAction, TraceStatus::completeWithError);

			// check if we should abort the method
			// Remark: a request to abort the method is signaled 
			// by raising the 'methodAborted ' error id
			if (err.GetId() == IDE::methodAborted)
				abort;

			// re-throw the error 
			Error::RaiseLast();
		}
	}

	function MeasureContainerVolume(
		device& ML_STAR,
		sequence& targetSequence,
		variable autoIncrement,
		variable& channelPattern,
		variable cLLDSensitivity,
		variable pLLDSensitivity,
		variable maxHeightDifference) variable
	{
		return(InternalMeasureContainerVolume(	ML_STAR, 
															targetSequence, 
															autoIncrement, 
															channelPattern, 
															cLLDSensitivity, 
															pLLDSensitivity, 
															maxHeightDifference,
															hslFalse));					// connectedContainers
	}

	function MeasureContainerVolume2(
		device& ML_STAR,
		sequence& targetSequence,
		variable autoIncrement,
		variable& channelPattern,
		variable cLLDSensitivity,
		variable pLLDSensitivity,
		variable maxHeightDifference) variable
	{
		return(InternalMeasureContainerVolume(	ML_STAR, 
															targetSequence, 
															autoIncrement, 
															channelPattern, 
															cLLDSensitivity, 
															pLLDSensitivity, 
															maxHeightDifference,
															hslTrue));					// connectedContainers
	}

	function GetContainerVolume(variable channel) variable
	{
		// initialize core of library
		InitHSLML_STARLibraryCore();

		// check input parameters to be valid
		if (!Util::IsInteger(channel))
			Error::Raise(IDE::invalidChannelNumber, GetFileName(), GetFunctionName(), GetLineNumber());
		if (channel < 1 || Global::containerVolume.GetSize() < channel)
			Error::Raise(IDE::invalidChannelNumber, GetFileName(), GetFunctionName(), GetLineNumber());

		return(Global::containerVolume.GetAt(channel - 1));
	}

	// --------------------------------------------------------------------------------------
	// String Constants
	// --------------------------------------------------------------------------------------

	namespace StringConstants
	{
		// data
		static const variable carWidthTKey("MlStarCarWidthAsT");				// key for labware data
		static const variable carIsLoadableKey("MlStarCarIsLoadable");		// key for labware data
		static const variable tipRackKey("MlStarTipRack");						// key for labware data
		static const variable carCountOfBCPosKey("MlStarCarCountOfBCPos");// key for labware data
		static const variable carFirstBCPosKey("MlStarCarFirstBCPos");		// key for labware data
		static const variable carBCReadWidthKey("MlStarCarBCReadWidth");	// key for labware data
		static const variable carRasterWidthKey("MlStarCarRasterWidth");	// key for labware data
		static const variable templateDefaultName("default");					// template default name
		static const variable tipCountingId("TipCount");						// tip count identifier
		static const variable barcodeFileExt1("_Barcodes.txt");				// extension of barcode file
		static const variable barcodeFileExt2(".xls");							// extension of formated barcode file
		static const variable worklistFileExt(".xls");							// extension of intermediate worklist file
		static const variable liquidClassFileExt(".csv");						// extension of file containing extended liquid class information
		static const variable worklistFileCopyExt("~.csv");					// extension of copy of worklist file
		static const variable configDirectory("Config");						// name of config directory
		static const variable barcodeFileTable("Barcodes");					// table name in formated barcode file
		static const variable worklistFileTable("Worklist");					// table name in intermediate worklist file
		static const variable worklistDelimiter(";");							// delimiter used in worklist
		static const variable liquidClassDelimiter(",");						// delimiter used in file containing extended liquid class information
		static const variable textFileExtensions("txt,csv,tab,asc");		// text files extensions

	}

	// --------------------------------------------------------------------------------------
	// Number Constants
	// --------------------------------------------------------------------------------------

	namespace NumberConstants
	{
		// data
		static const variable userResponseTime(24*24*60*60);					// user response time [s]
		static const variable reverseSequenceCount(24);							// count of reverse tip pickup sequence
	}

	// --------------------------------------------------------------------------------------
	// Tip Types
	// --------------------------------------------------------------------------------------

	namespace TipType
	{
		static const variable lowVolumeTip("LowVolumeTip");											// low volume tip type
		static const variable standardVolumeTip("StandardVolumeTip");								// standard volume tip type
		static const variable highVolumeTip("HighVolumeTip");											// high volume tip type
		static const variable lowVolumeTipWithFilter("LowVolumeTipWithFilter");					// low volume tip type with filter
		static const variable standardVolumeTipWithFilter("StandardVolumeTipWithFilter");	// standard volume tip type with filter
		static const variable highVolumeTipWithFilter("HighVolumeTipWithFilter");				// high volume tip type with filter
	}

	namespace TipTypeNum
	{
		static const variable standardVolumeTip("0");							// standard volume tip type
		static const variable lowVolumeTip("2");									// low volume tip type
		static const variable highVolumeTip("4");									// high volume tip type
		static const variable lowVolumeNeedle("6");								// low volume needle type
		static const variable standardVolumeNeedle("7");						// standard volume needle type
		static const variable highVolumeNeedle("8");								// high volume needle type
		static const variable standardVolumeTipWithFilter("1");				// standard volume tip type with filter
		static const variable lowVolumeTipWithFilter("3");						// low volume tip type with filter
		static const variable highVolumeTipWithFilter("5");					// high volume tip type with filter
	}

	// --------------------------------------------------------------------------------------
	// Volumes
	// --------------------------------------------------------------------------------------

	namespace TipVolume
	{
		static const variable low(10.0);												// volume of low volume tip [ul]
		static const variable standard(300.0);										// volume of standard volume tip [ul]
		static const variable high(1000.0);											// volume of high volume tip [ul]
		static const variable lowWithFilter(10.0);								// volume of low volume tip with filter [ul]
		static const variable standardWithFilter(300.0);						// volume of standard volume tip with filter [ul]
		static const variable highWithFilter(1000.0);							// volume of high volume tip with filter [ul]
		static variable current[];														// current volume in the tip [ul]
	}

	// --------------------------------------------------------------------------------------
	// Deck Definition
	// --------------------------------------------------------------------------------------

	namespace DeckDef
	{
		static const variable templateDimDy(497);									// y dimension of a template carrier [mm]
		static		 variable deckRaster(22.5);									// deck raster [mm]
		static		 variable baseOffsetOfX(100.0);								// x-offset of leftmost deck site [mm]
		static		 variable baseOffsetOfY(63.0);								// y-offset of leftmost deck site [mm]
		static const variable numberOfSites(54);									// number of deck sites for carriers
		static const variable epsilon(5.0);											// epsilon [mm] (deck sites s1 and s2 are considered to be the same if |s1X - s2X| < epsilon)
		static const variable longMax(2147483647);								// maximum long value 
		static		 variable deckDefInitialized(hslFalse);					// deck definition initialized flag

		function GetLabwareAtSites(device& ML_STAR, string& labwareIds[])
		{
			variable carWidthTValue(0);
			variable carIsLoadableValue(hslFalse);
			variable carCountOfBCPosValue(0);
			variable carFirstBCPosValue(0);
			variable carBCReadWidthValue(0);
			variable carRasterWidthValue(0);
			variable index;												// loop counter
			variable index2;												// loop counter
			variable index3;												// loop counter
			variable index4;												// loop counter
			variable size;													// array size
			variable size2;												// array size
			variable size3;												// array size
			variable arrIndex;											// array index
			variable templateName;										// place to hold template name
			variable templateNames[];									// place to hold template names 
			variable labwareNames[];									// place to hold labware names 
			variable labwareCoords[];									// place to hold x-y-z-coordinates
			variable labwareCoordX;										// place to hold an x-coordinate
			variable propertyKeys[];									// place to hold property keys
			variable propertyValues[];									//	place to hold property values
			variable isTemplate(hslTrue);								// indicates whether the labware is realy a template or not
			variable labwareSiteCoordsX[];							// place to hold labware sites on the deck (slots,tracks or whatever)

			// initialize DeckDef::deckRaster etc. from the device's configuration file
			if (!deckDefInitialized)
			{
				deckRaster = 1.0 * ML_STAR.GetCfgValueWithKey(MlStarCfgKey::deckRaster);
				baseOffsetOfX = 1.0 * ML_STAR.GetCfgValueWithKey(MlStarCfgKey::deckXOffset);
				baseOffsetOfY = 1.0 * ML_STAR.GetCfgValueWithKey(MlStarCfgKey::deckYOffset);
				deckDefInitialized = hslTrue;
			}

			// initialize output params
			labwareIds.SetSize(0);
			labwareIds.SetSize(numberOfSites);

			// initialize site coordinates
			for (index = 0; index <= numberOfSites; index++)
				labwareSiteCoordsX.AddAsLast(baseOffsetOfX + index * deckRaster);

			// dump site coordinates
			#ifdef _DEBUG
			size = labwareSiteCoordsX.GetSize();
			for (index = 0; index < size; index++)
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "labwareSiteCoordsX[", index, "] = ", labwareSiteCoordsX.GetAt(index));
			#endif
			
			// get labware names with associated template name
			ML_STAR.GetTemplateLabwareNames(templateNames, labwareNames);

			// dump template labware names
			#ifdef _DEBUG
			FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "template labware names:");
			size = templateNames.GetSize();
			for (index = 0; index < size; index++)
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, Util::FillRight(templateNames.GetAt(index), " ", 32), labwareNames.GetAt(index));
			#endif

			// iterate over labware names and collect associated x-y-z-coordinates
			propertyKeys.AddAsLast(StringConstants::carWidthTKey);
			propertyKeys.AddAsLast(StringConstants::carIsLoadableKey);
			propertyKeys.AddAsLast(StringConstants::carCountOfBCPosKey);
			propertyKeys.AddAsLast(StringConstants::carFirstBCPosKey);
			propertyKeys.AddAsLast(StringConstants::carBCReadWidthKey);
			propertyKeys.AddAsLast(StringConstants::carRasterWidthKey);
			size = templateNames.GetSize();
			for (index = 0; index < size; index++)
			{
				isTemplate = hslTrue;
				templateName = templateNames.GetAt(index);
				if (StringConstants::templateDefaultName == templateName)
				{
					if (!Util::Lookup(templateNames, labwareNames.GetAt(index), arrIndex))
						// not really a template
						isTemplate = hslFalse;
					templateName = labwareNames.GetAt(index);
				}

				ML_STAR.GetLabwarePositionEx(templateName, labwareCoords);
				ML_STAR.GetLabwareData(templateName, propertyKeys, propertyValues);
				if (0 < propertyValues.GetSize())
					// labware supports key MlStarCarWidthAsT
					carWidthTValue = IVal(propertyValues.GetAt(0));
				else
					carWidthTValue = 0;
				if (1 < propertyValues.GetSize())
					// labware supports key MlStarCarIsLoadable
					carIsLoadableValue = IVal(propertyValues.GetAt(1));
				else
					carIsLoadableValue = hslFalse;

				if ((0 < carWidthTValue) && carIsLoadableValue)
				{
					// NOTE: The position of a non-template carrier (e.g. 1T carrier) is not the position of the lower left 
					// corner but the position of the center of the lower left and the lower right corner (strange but true).

					if (!isTemplate)
						labwareCoords.SetAt(0, labwareCoords.GetAt(6));// boundary 1 x-coord

					labwareCoordX = labwareCoords.GetAt(0) + carWidthTValue * deckRaster;

					#ifdef _DEBUG
					FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "templateName = ", templateName);
					FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "carWidthTValue = ", carWidthTValue);
					FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "labwareCoordXLeft = ", labwareCoords.GetAt(0));
					FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "labwareCoordXRight = ", labwareCoordX);
					#endif

					size2 = labwareSiteCoordsX.GetSize();
					for (index2 = 0; index2 < size2; index2++)
					{
						if (Util::Abs(labwareCoordX - labwareSiteCoordsX.GetAt(index2)) < epsilon)
						{
							if (isTemplate)
							{
								// add ids of labware placed on the template
								variable errorDesc;													// error description
								variable labwareName;
								variable templateLabwareNames[];
								variable templateLabwareCoordsY[];
								variable hasRectBoundary(hslTrue);								// indicates whether labware has rectangular boundaries
								variable templateLabwareCoordsYTop[];							// place to hold y-coordinate of top boundary of labware placed on a template
								variable templateLabwareCoordsYBottom[];						// place to hold y-coordinate of bottom boundary of labware placed on a template
								variable templateLabwareSiteCoordsY[];							// place to hold labware sites on the template (y-coordinate of the mid of the plates)
								string templateLabwareAtPos[];									// place to hold labware ids at template position
								variable minPos;
								variable minDY;
								variable curDY;

								if (2 < propertyValues.GetSize())
								{
									// labware supports key MlStarCarCountOfBCPos
									carCountOfBCPosValue = IVal(propertyValues.GetAt(2));
								}
								else
								{
									errorDesc = StringTable::Load(IDE::labwareDataKeyNotFound);
									StrReplace(errorDesc, "%s", StringConstants::carCountOfBCPosKey);
									Error::RaiseEx(IDE::labwareDataKeyNotFound, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
								}
								if (3 < propertyValues.GetSize())
								{
									// labware supports key MlStarCarFirstBCPos
									carFirstBCPosValue = IVal(propertyValues.GetAt(3)) / 10.0;
								}
								else
								{
									errorDesc = StringTable::Load(IDE::labwareDataKeyNotFound);
									StrReplace(errorDesc, "%s", StringConstants::carFirstBCPosKey);
									Error::RaiseEx(IDE::labwareDataKeyNotFound, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
								}
								if (4 < propertyValues.GetSize())
								{
									// labware supports key MlStarCarBCReadWidth
									carBCReadWidthValue = IVal(propertyValues.GetAt(4)) / 10.0;
								}
								else
								{
									errorDesc = StringTable::Load(IDE::labwareDataKeyNotFound);
									StrReplace(errorDesc, "%s", StringConstants::carBCReadWidthKey);
									Error::RaiseEx(IDE::labwareDataKeyNotFound, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
								}
								if (5 < propertyValues.GetSize())
								{
									// labware supports key MlStarCarRasterWidth
									carRasterWidthValue = IVal(propertyValues.GetAt(5)) / 10.0;
								}
								else
								{
									errorDesc = StringTable::Load(IDE::labwareDataKeyNotFound);
									StrReplace(errorDesc, "%s", StringConstants::carRasterWidthKey);
									Error::RaiseEx(IDE::labwareDataKeyNotFound, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
								}

								// initialize site coordinates
								ML_STAR.GetLabwarePosition(templateName, labwareCoords);
								for (index3 = 0; index3 < carCountOfBCPosValue; index3++)
								{
									templateLabwareSiteCoordsY.AddAsLast(labwareCoords.GetAt(1) + DeckDef::templateDimDy - 
																					 carFirstBCPosValue - index3 * carRasterWidthValue);
								}

								for (index3 = 0; index3 < size; index3++)
								{
									if (templateNames.GetAt(index3) == templateName)
									{
										labwareName = labwareNames.GetAt(index3);
										ML_STAR.GetLabwarePositionEx(labwareName, labwareCoords);
										templateLabwareNames.AddAsLast(labwareName);
										templateLabwareCoordsY.AddAsLast(labwareCoords.GetAt(1));
										hasRectBoundary = hasRectBoundary && (labwareCoords.GetAt(7) != 0) && (labwareCoords.GetAt(13) != 0);
										templateLabwareCoordsYBottom.AddAsLast(labwareCoords.GetAt(7));
										templateLabwareCoordsYTop.AddAsLast(labwareCoords.GetAt(13));
									}
								}
								templateLabwareAtPos.SetSize(carCountOfBCPosValue);
								if (!hasRectBoundary)
								{
									size3 = Util::Min(templateLabwareCoordsY.GetSize(), templateLabwareAtPos.GetSize());
									for (index3 = 0; index3 < size3; index3++)
									{
										minDY = longMax;
										for (index4 = 0; index4 < carCountOfBCPosValue; index4++)
										{
											curDY = Util::Abs(templateLabwareCoordsY.GetAt(index3) - templateLabwareSiteCoordsY.GetAt(index4));
											if (curDY < minDY)
											{
												minPos = index4;
												minDY = curDY;
											}
										}
										templateLabwareAtPos.SetAt(minPos, templateLabwareNames.GetAt(index3));
									}
								}
								else
								{
									size3 = templateLabwareNames.GetSize();
									for (index3 = 0; index3 < carCountOfBCPosValue; index3++)
									{
										for (index4 = 0; index4 < size3; index4++)
										{
											if (templateLabwareSiteCoordsY.GetAt(index3) < templateLabwareCoordsYTop.GetAt(index4) && 
												 templateLabwareCoordsYBottom.GetAt(index4) < templateLabwareSiteCoordsY.GetAt(index3))
											{
												templateLabwareAtPos.SetAt(index3, templateLabwareNames.GetAt(index4));
												break;
											}
										}
									}
								}
								size3 = templateLabwareAtPos.GetSize();
								for (index3 = 0; index3 < size3; index3++)
								{
									labwareName = templateLabwareAtPos.GetAt(index3);
									templateName = templateName + ";";
									if ("" != labwareName)
										templateName = templateName + labwareName;
								}
								templateName = templateName + ";";
							}

							labwareIds.SetAt(index2 - 1, templateName);

							break;
						}
					}
				}
			}

			// dump labware at sites
			#ifdef _DEBUG
			size = labwareIds.GetSize();
			for (index = 0; index < size; index++)
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "labwareIds[", index + 1, "] = ", labwareIds.GetAt(index));
			#endif
		}
	}

	// --------------------------------------------------------------------------------------
	// Barcode File Handling
	// --------------------------------------------------------------------------------------

	// The DeleteBarcodeFile function deletes an existing barcode file. 

	function DeleteBarcodeFile(
		variable& barcodeFileName)	variable				// i: A string that specifies the barcode file to be deleted.
																	//    If this parameter is empty the function tries to delete 
																	//		a barcode file with the name <methodPathAndBaseName>_Barcodes.txt
	{
		variable traceSource("");							// source for formated trace
		variable traceAction("");							// action for formated trace
		variable barcodeFileNameCopy;

		// activate error handler
		onerror goto Unexpected;

		// initialize HSLML_STAR library
		InitHSLML_STARLibraryCore();

		// trace start of formating
		traceSource = StringTable::Load(IDS::traceSource);
		traceAction = StringTable::Load(IDS::traceActionDeleteBarcodeFile);
		FormatTrace(traceSource, traceAction, TraceStatus::start);

		// dump input params
		#ifdef _DEBUG
		FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "barcodeFileName = ", barcodeFileName);
		#endif

		// check input parameters to be valid
		if (!Util::IsString(barcodeFileName))
			Error::Raise(IDE::invalidFileName, GetFileName(), GetFunctionName(), GetLineNumber());

		// trace completion of formating
		FormatTrace(traceSource, traceAction, TraceStatus::complete);
	
		// delete barcode file
		barcodeFileNameCopy = barcodeFileName;
		if ("" == barcodeFileNameCopy)
		{
			// barcode file name has not been set by the user,
			// setup default barcode file name
			variable index;
			variable methodName;
			methodName = GetMethodFileName();
			//>> 20060523
			if ("" == methodName)
			{
				methodName = GetWorkflowFileName();
			}
			//<< 20060523
			index = StrReverseFind(methodName, ".");
			if (0 <= index)
				methodName = StrLeft(methodName, index);
			index = StrReverseFind(methodName, "\\");
			if (0 <= index)
				methodName = StrMid(methodName, index + 1, StrGetLength(methodName));
			barcodeFileNameCopy = GetLogFilesPath() + "\\" + methodName + StringConstants::barcodeFileExt1;
		}
		if (StrMid(barcodeFileNameCopy, 0, 1) != "\"")
			 barcodeFileNameCopy = "\"" + barcodeFileNameCopy;
		if (StrMid(barcodeFileNameCopy, StrGetLength(barcodeFileNameCopy) - 1, 1) != "\"")
			 barcodeFileNameCopy = barcodeFileNameCopy + "\"";
		Shell(CmdInterpreter::cmdPrompt + " /c del " + barcodeFileNameCopy, hslHide, hslSynchronous);

		return(hslTrue);

		Unexpected:
		{

			// trace completion with error of formating
			FormatTrace(traceSource, traceAction, TraceStatus::completeWithError);

			// re-throw the error 
			Error::RaiseLast();
		}
	}

	//	Converts the weakly formated barcode file 'barcodeFileName', written as ASCII text file 
	//	by the LoadCarrier step, into a strongly formated barcode file 'formatedBarcodeFileName' 
	//	using the following format:
	//	
	//	"Id"				record id (integer)
	//	"Specifier"		specifier (string), P = Position, C = Carrier
	//	"Position"		position (integer)
	//	"Barcode"		barcode (string)
	//	"Timestamp"		timestamp, YYYY-MM-DD hh:mm:ss (string)
	//	"LabwareId"		labware id (string)
	//	
	//	The strongly formated barcode file 'formatedBarcodeFileName' may be an ASCII text file, a 
	//	Microsoft Excel, or a Microsoft Access file. If no barcode is available for 
	// a labware element, the string 'No barcode' will be written to the associated 
	// field in the column 'Barcode' . If no labware is available for a deck site, the 
	// string 'No labware' will be written to the associated field in the column 'LabwareId'.

	//	
	//	Examples:
	//	
	//	variable logPath("C:\\Program Files\\Hamilton\\logfiles\\");
	//	FormatBarcodeFile(logPath + "barcode_1.txt", logPath + "barcode__1.txt");
	//	FormatBarcodeFile(logPath + "barcode_1.txt", logPath + "barcode__1.xls barcode_1");
	//	FormatBarcodeFile(logPath + "barcode_1.txt", logPath + "barcode__1.mdb barcode_1");

	function FormatBarcodeFile(
		device& ML_STAR,
		variable& barcodeFileName,
		variable& formatedBarcodeFileName) variable
	{
		file source;											// source file
		file target;											// target file
		variable barcodeFilePathName("");				// path and name of barcode file
		variable id(0);										// colunm variable
		variable specifier("");								// colunm variable
		variable position(0);								// colunm variable
		string barcode("");									// colunm variable
		string timestamp("");								// colunm variable
		string labwareId("");								// colunm variable
		variable index(0);									// an index
		variable length(0);									// a length
		variable index2(0);									// another index
		variable length2(0);									// another length
		string beginRecord("BEGIN_RECORD");				// begin record keyword
		string endRecord("END_RECORD");					// end record keyword
		string carrier("C");									// carrier keyword
		string recordEntry;									// a record entry
		string fieldDelimiter("\t");						// field delimiter used in the source file
		variable traceSource("");							// source for formated trace
		variable traceAction("");							// action for formated trace
		string labwareIds[];									// place to hold labware ids at deck sites
		string labwareIds2[];								// place to hold labware ids at carrier sites
		variable noBarcode("");								// place to load the string 'No barcode' from the string table
		variable noLabware("");								// place to load the string 'No labware' from the string table
		variable errorDesc;									// error description

		// activate error handler
		onerror goto Unexpected;

		// initialize HSLML_STAR library
		InitHSLML_STARLibraryCore();

		// trace start of formating
		traceSource = StringTable::Load(IDS::traceSource);
		traceAction = StringTable::Load(IDS::traceActionFormatBarcodeFile);
		FormatTrace(traceSource, traceAction, TraceStatus::start);

		// search the barcode file
		barcodeFilePathName = SearchPath(barcodeFileName);
		if ("" == barcodeFilePathName)
			barcodeFilePathName = SearchPath(GetLogFilesPath() + "\\" + barcodeFileName);

		// dump input params
		#ifdef _DEBUG
		FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "barcodeFileName = ", barcodeFileName);
		FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "barcodeFilePathName = ", barcodeFilePathName);
		FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "formatedBarcodeFileName = ", formatedBarcodeFileName);
		#endif

		// check input parameters to be valid
		if (!Util::IsString(barcodeFileName))
			Error::Raise(IDE::invalidFileName, GetFileName(), GetFunctionName(), GetLineNumber());
		if ("" == barcodeFileName)
			Error::Raise(IDE::invalidFileName, GetFileName(), GetFunctionName(), GetLineNumber());
		if ("" == barcodeFilePathName)
		{
			errorDesc = StringTable::Load(IDE::fileNotFound);
			StrReplace(errorDesc, "%s", barcodeFileName);
			Error::RaiseEx(IDE::fileNotFound, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
		}
		if (!Util::IsString(formatedBarcodeFileName))
			Error::Raise(IDE::invalidFileName, GetFileName(), GetFunctionName(), GetLineNumber());
		if ("" == formatedBarcodeFileName)
			Error::Raise(IDE::invalidFileName, GetFileName(), GetFunctionName(), GetLineNumber());

		// get labware ids at sites
		DeckDef::GetLabwareAtSites(ML_STAR, labwareIds);

		// format barcode file
		noBarcode = StringTable::Load(IDS::noBarcode);
		noLabware = StringTable::Load(IDS::noLabware);
		target.SetDelimiter(hslCSVDelimited);
		target.AddField("Id", id, hslInteger);
		target.AddField("Specifier", specifier, hslString);
		target.AddField("Position", position, hslInteger);
		target.AddField("Barcode", barcode, hslString);
		target.AddField("Timestamp", timestamp, hslString);
		target.AddField("LabwareId", labwareId, hslString);
		if (!target.Open(formatedBarcodeFileName, hslAppend))
		{
			errorDesc = StringTable::Load(IDE::fileOpenFailed);
			StrReplace(errorDesc, "%s", formatedBarcodeFileName);
			Error::RaiseEx(IDE::fileOpenFailed, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
		}
		if (0 != target.Seek(0, hslLast))
			target.ReadRecord();
		source.SetDelimiter(";");		// Opening the unformatted barcode file results in a Phoenix Error if the regional settings use the comma as decimal symbol.
		if (!source.Open(barcodeFilePathName, hslAppend))
		{
			errorDesc = StringTable::Load(IDE::fileOpenFailed);
			StrReplace(errorDesc, "%s", barcodeFilePathName);
			Error::RaiseEx(IDE::fileOpenFailed, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
		}
		while (!source.Eof())
		{
			recordEntry = source.ReadString();
			length = recordEntry.GetLength();
			if (0 <= recordEntry.Find(beginRecord))
			{
				recordEntry = recordEntry.Mid(beginRecord.GetLength() + 1, length);
				timestamp = recordEntry;
			}
			else
			{
				if (-1 == recordEntry.Find(endRecord))
				{
					index = recordEntry.Find(fieldDelimiter);
					specifier = recordEntry.Left(index);
					recordEntry = recordEntry.Mid(index + 1, length);
					index = recordEntry.Find(fieldDelimiter);
					position = recordEntry.Left(index);
					barcode = recordEntry.Mid(index + 1, length);
					labwareId = "";
					position = IVal(position);
					if (carrier.Compare(specifier) == 0)
					{
						// it's a carrier
						labwareIds2.SetSize(0);
						if (position <= labwareIds.GetSize())
							//labwareId = labwareIds.GetAt(position);
							labwareId = labwareIds.GetAt(position - 1);
						index2 = labwareId.Find(";");
						length2 = labwareId.GetLength();
						while (0 <= index2)
						{
							labwareIds2.AddAsLast(labwareId.Left(index2)); 
							labwareId = labwareId.Mid(index2 + 1, length2);
							index2 = labwareId.Find(";");
							length2 = labwareId.GetLength();
						}
						if (0 < length2)
							labwareIds2.AddAsLast(labwareId);
						if (0 < labwareIds2.GetSize())
							labwareId = labwareIds2.GetAt(0);
					}
					else
					{
						// it's not a carrier
						if (position < labwareIds2.GetSize())
						{
							labwareId = labwareIds2.GetAt(position);
						}
						else
						{
							if (0 < labwareIds2.GetSize())
								labwareId = labwareIds2.GetAt(0);
						}
					}
					if (0 == barcode.GetLength())
						barcode = noBarcode;
					if (0 == labwareId.GetLength())
						labwareId = noLabware;
					id++;
					if (!target.WriteRecord())
						Error::Raise(IDE::fileWriteFailed, GetFileName(), GetFunctionName(), GetLineNumber());
				}
			}
		}

		// trace completion of formating
		FormatTrace(traceSource, traceAction, TraceStatus::complete);

		return(hslTrue);

		Unexpected:
		{

			// trace completion with error of formating
			FormatTrace(traceSource, traceAction, TraceStatus::completeWithError);

			// re-throw the error 
			Error::RaiseLast();
		}
	}

	// --------------------------------------------------------------------------------------
	// Worklist Iterator
	// --------------------------------------------------------------------------------------

	namespace Iterator
	{
		static variable synchronisator[];							// place to hold synchonization lines (Wash, Flush or Break steps)

		static function EndOfFile(										// tests for end of file 
			variable& iterator[])										// i: iterator
		{
			variable index;
			variable size;

			size = iterator.GetSize();
			for (index = 1; index < size; index++)
			{
				if (iterator.GetAt(index) != 0)
					return(hslFalse);
			}
			return(hslTrue);
		}

		static function SynchronizeNow(								// tests for synchronization
			variable& iterator[])										// i: iterator
		{
			variable index;
			variable size;

			size = synchronisator.GetSize();
			for (index = 1; index < size; index++)
			{
				if (synchronisator.GetAt(index) == 0 && iterator.GetAt(index) != 0)
					return(hslFalse);
			}
			return(hslTrue);
		}

		static function FindNext(										// searches the worklist file for the first / last row that satisfies the specified criteria
			file& worklistFile,											// i: worklist file
			variable skipRows,											// i: specifies the row offset from the current row or start
			variable start,												// i: start position, (hslFirst, hslCurrent or hslLast)
			variable& criteria1,											// i: criteria 1
			variable& criteria2,											// i: criteria 2
			variable& criteria3,											// i: criteria 3
			variable orLogic)												// i: indicates whether to use OR / AND logic
		{
			variable row1(0);												// a row 
			variable row2(0);												// a row 
			variable row3(0);												// a row 
			variable nextRow(0);											// next row 
			variable currentRowBak;										// backup of current row 

			// backup current row
			currentRowBak = worklistFile.Seek(0, hslCurrent);

			// do a multi seek
			if ("" != criteria1)
			{
				row1 = worklistFile.Seek(skipRows, start, criteria1);
				// restore current row
				worklistFile.Seek(currentRowBak - 1, hslFirst);
			}
			if ("" != criteria2)
			{
				row2 = worklistFile.Seek(skipRows, start, criteria2);
				// restore current row
				worklistFile.Seek(currentRowBak - 1, hslFirst);
			}
			if ("" != criteria3)
			{
				row3 = worklistFile.Seek(skipRows, start, criteria3);
				// restore current row
				worklistFile.Seek(currentRowBak - 1, hslFirst);
			}

			// determine next row
			if (orLogic)
			{
				if (0 < row1 && 0 < row2)
					nextRow = Util::Min(row1, row2);
				else
					nextRow = Util::Max(row1, row2);

				if (0 < nextRow && 0 < row3)
					nextRow = Util::Min(nextRow, row3);
				else
					nextRow = Util::Max(nextRow, row3);
			}
			else
			{
				if (0 < row1 && 0 < row2)
					nextRow = Util::Max(row1, row2);

				if (0 < nextRow && 0 < row3)
					nextRow = Util::Max(nextRow, row3);
			}

			// set the file pointer to the next row
			worklistFile.Seek(nextRow - 1, hslFirst);

			// return mext row
			return(nextRow);
		}

		static function SetToFirst(									// sets the iterator to the first elements starting at the specified line
			file& worklistFile,											// i: worklist file
			string& channelPattern,										// i: channel pattern
			variable& iterator[],										// i: iterator
			variable skipRows)											// i: specifies the row offset from the first row
		{
			variable row1;													// a row 
			variable row2;													// another row 
			variable currentRowBak;										// backup of current row 
			variable channel;												// a channel
			variable numberOfChannels;									// number of channels

			// get number of channels 
			numberOfChannels = channelPattern.GetLength();

			// extra field 0 of the synchronisator is unused 
			synchronisator.SetSize(0);
			synchronisator.SetSize(numberOfChannels + 1);

			// extra field 0 of the iterator is used to store 
			// the max of the already visited lines
			iterator.SetSize(0);
			iterator.SetSize(numberOfChannels + 1);

			// let the first channel point to the first line 
			// not being a Wash, Flush or Break step
			row1 = FindNext(worklistFile, skipRows - 1, hslFirst, "F1 <> 'W'", "F1 <> 'F'", "F1 <> 'B'", hslFalse);

			// check for end of file
			if (0 == row1)
				// we are done
				return(EndOfFile(iterator));

			// iterate over channels
			for (channel = 1; channel <= numberOfChannels; channel++)
			{
				// check if the channel is active
				if ("1" == channelPattern.Mid(channel - 1, 1))
				{
					// found an active channel
					if (1 < channel)
					{
						// let the channel point to the next line 
						// behind the next Wash, Flush or Break step
						row1 = FindNext(worklistFile, 0, hslCurrent, "F1 = 'W'", "F1 = 'F'", "F1 = 'B'", hslTrue);

						// check for end of file
						if (0 == row1)
							// we are done
							return(EndOfFile(iterator));

						// backup current row
						currentRowBak = worklistFile.Seek(0, hslCurrent);

						// find the next Break step
						row2 = worklistFile.Seek(0, hslCurrent, "F1 = 'B'");

						// restore current row
						worklistFile.Seek(currentRowBak - 1, hslFirst);

						// increment current row
						row1 = worklistFile.Seek(1, hslCurrent);

						// check if we land behind a Break step
						if (row1 - 1 == row2)
							// we land behind a Break step,
							// let the channel point to the 0 line 
							return(EndOfFile(iterator));

						// check if we land on a Break step
						if (row1 == row2)
							// we land on a Break step,
							// let the channel point to the 0 line 
							return(EndOfFile(iterator));
					}

					// set the channel pointer
					iterator.SetAt(channel, row1);
					iterator.SetAt(0, Util::Max(iterator.GetAt(0), row1));
				}
			}
			return(EndOfFile(iterator));
		}

		static function SetToNext(									// sets the iterator to the first elements starting at the specified line
			file& worklistFile,										// i: worklist file
			string& channelPattern,									// i: channel pattern
			variable& iterator[])									// i: iterator
		{
			variable eof;												// indicates end of file
			variable row1;												// a row
			variable row2;												// another row
			variable channel;											// a channel
			variable numberOfChannels;								// number of channels
			variable iteratorCopy[];								// copy of iterator

			// backup current state of iterator
			iteratorCopy = iterator;
			numberOfChannels = channelPattern.GetLength();

			// always reset the iterator after a Wash, Flush or Break step
			row1 = iterator.GetAt(0);
			row2 = FindNext(worklistFile, row1 - 1, hslFirst, "F1 = 'W'", "F1 = 'F'", "F1 = 'B'", hslTrue);
			if (row1 == row2)
			{
				// it's a wash Wash, Flush or Break step,
				// set to first after the max of the already visited lines
				eof = SetToFirst(worklistFile, channelPattern, iterator, row1 + 1);
				return(eof);
			}

			// iterate over channels
			for (channel = 1; channel <= numberOfChannels; channel++)
			{
				// check if the channel is active
				if ("1" == channelPattern.Mid(channel - 1, 1) && 0 < iterator.GetAt(channel))
				{
					// found an active channel,
					// let the channel point to the next line before the next Wash, Flush or Break step
					row1 = worklistFile.Seek(iterator.GetAt(channel) - 1, hslFirst);
					row2 = FindNext(worklistFile, 1, hslCurrent, "F1 <> 'W'", "F1 <> 'F'", "F1 <> 'B'", hslFalse);
					if (row1 + 1 != row2)
					{
						// let the channel point to the 0 line 
						row2 = 0;

						// set the sychronization pointer
						synchronisator.SetAt(channel, row1 + 1);
						synchronisator.SetAt(0, Util::Max(synchronisator.GetAt(0), row1 + 1));
						if (SynchronizeNow(iterator))
						{
							iterator = synchronisator;
							return(EndOfFile(iterator));
						}
					}

					// set the channel pointer
					iterator.SetAt(channel, row2);
					iterator.SetAt(0, Util::Max(iterator.GetAt(0), row2));
				}
			}

			// test for end of file
			eof = EndOfFile(iterator);
			if (eof)
			{
				for (channel = 1; channel <= numberOfChannels; channel++)
				{
					// check if the channel is active
					if ("1" == channelPattern.Mid(channel - 1, 1))
					{
						// found an active channel
						row1 = worklistFile.Seek(iteratorCopy.GetAt(channel) - 1, hslFirst);
						row2 = FindNext(worklistFile, 1, hslCurrent, "F1 = 'W'", "F1 = 'F'", "F1 = 'B'", hslTrue);
						if (row1 + 1 != row2)
							row2 = 0;
						iterator.SetAt(channel, row2);
						iterator.SetAt(0, Util::Max(iterator.GetAt(0), row2));
					}
				}
			}
			return(EndOfFile(iterator));
		}

		static function DumpIterator(									// dumps the iterator and the synchronisator
			variable& iterator[])
		{
			// dump iterator
			#ifdef _DEBUG
			variable index;
			variable size;
			size = iterator.GetSize();
			for  (index = 0; index < size; index++)
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "iterator[", index, "] = ", iterator.GetAt(index));
			size = synchronisator.GetSize();
			for (index = 0; index < size; index++)
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "synchronisator[", index, "] = ", synchronisator.GetAt(index));
			#endif
		}
	}

	// --------------------------------------------------------------------------------------
	// Pipetting Control Block
	// --------------------------------------------------------------------------------------

	namespace PCB
	{

		// data

		// general settings 

		static variable UserResponseTime(NumberConstants::userResponseTime);		// user response time [s]
		static variable ErrorHandling(ErrorHandling::continue);						// error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
		static variable TipCountingEnabled(hslFalse);									// tip counting enabled flag
		static variable TipCountingIdentifier(StringConstants::tipCountingId);	// tip count identifier

		// initialize settings 

		static variable InitializeUseDefaultWaste(hslTrue);							// indicates whether to use the default waste (0 = off, 1 = on)
		static sequence InitializeWasteDestination;										// initialize waste destination
		static variable InitializeSequenceCounting(0);									// sequence counting (0 = manually, 1 = automatic)
		static variable InitializeChannelUse(1);											// channel use (1 = all sequence positions, 2 = channel pattern)
		static variable InitializeAlways(hslFalse);										// initialize always flag
		static variable InitializeEnabled(hslTrue);										// initialize enabled flag (0 = disabled, 1 = enabled)
		static variable InitializeChannelVariable("");									// channel variable (0 = unused, 1 = used)

		static global variable hslML_STARLibInitializedPipettingDevices[];		// place to hold names of initialized pipetting devices

		// tip pickup settings 

		static sequence TipPickupSequence;													// original tip pickup sequence
		static variable TipPickupSequenceCounting(0);									// sequence counting (0 = manually, 1 = automatic)
		static variable TipPickupTipType("");												// tip type
		static variable TipPickupChannelUse(1);											// channel use (1 = all sequence positions, 2 = channel pattern)
		static variable TipPickupEnabled(hslTrue);										// tip pickup enabled flag (0 = disabled, 1 = enabled)
		static variable TipPickupNow(hslTrue);												// tip pickup now flag (0 = deferred, 1 = now)
		static variable TipPickupReverseSequenceCount(NumberConstants::reverseSequenceCount);// count of reverse tip pickup sequence
		static variable TipPickupChannelVariable("");									// channel variable (0 = unused, 1 = used)

		// tip eject settings 

		static variable TipEjectUseDefaultWaste(hslTrue);								// indicates whether to use the default waste (0 = off, 1 = on)
		static sequence TipEjectWasteDestination;											// tip eject waste destination
		static variable TipEjectChannelUse(1);												// channel use (1 = all sequence positions, 2 = channel pattern)
		static variable TipEjectSequenceCounting(0);										// sequence counting (0 = manually, 1 = automatic)
		static variable TipEjectChannelVariable("");										// channel variable (0 = unused, 1 = used)

		// aspirate settings 

		static sequence AspirateSequence;													// aspirate sequence
		static variable AspirateSequenceCounting(0);										// sequence counting (0 = manually, 1 = automatic)
		static variable AspirateChannelUse(1);												// channel use (1 = all sequence positions, 2 = channel pattern)
		static variable AspirateMode(0);														// aspirate mode (0 = aspiration, 1 = consecutive aspiration, 2 = empty cup aspiration)
		static variable AspirateCLLDSensitivity(0);										// capacitive liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		static variable AspirateFluidHeight(0);											// liquid height from bottom if liquid level detection is disabled
		static variable AspirateSubmergeDepth(2);											// submerge depth after the liquid level detection [mm]
		static variable AspirateVolumes[];													// aspirate volume per channel [ul]
		static variable AspirateChannelVariable("");										// channel variable (0 = unused, 1 = used)
		static variable AspirateMaxHeightDiff(0);											// the maximum difference between the two liquid level detection measurements [mm]
		static variable AspiratePLLDSensitivity(0);										// pressure liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		static variable AspirateLiquidFollowing(hslTrue);								// liquid following during aspirate and mix (0 = disabled, 1 = enabled)
		static variable AspiratePrerinsingMixCycles(0);									// prerinsing / mix cycles 
		static variable AspiratePrerinsingMixPosition(2);								// prerinsing / mix position [mm]
		static variable AspiratePrerinsingMixVolume(0);									// prerinsing / mix volume [ul]
		static variable AspirateUserDefinedLiquidClass("");							// liquid class name 
		static variable AspirateUserDefinedLiquidClasses[];							// liquid class name per sequence position in AspirateSequence 

		// dispense settings 

		static sequence DispenseSequence;													// dispense sequence
		static variable DispenseSubmergeDepth(2);											// submerge depth after the liquid level detection [mm]
		static variable DispenseVolumes[];													// dispense volume per channel [ul]
		static variable DispenseChannelVariable("");										// channel variable (0 = unused, 1 = used)
		static variable DispenseRestVolumeDestination(0);								// dispense rest volume destination (0 = waste, 1 = aspirate sequence)
		static variable DispenseRestVolumeFluidHeight(10);								// liquid height from bottom to dispense rest volume [mm]
		static variable DispenseChannelUse(1);												// channel use (1 = all sequence positions, 2 = channel pattern)
		static variable DispenseCLLDSensitivity(0);										// capacitive liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
		static variable DispenseSequenceCounting(0);										// sequence counting (0 = manually, 1 = automatic)
		static variable DispenseFluidHeight(0);											// liquid height from bottom if liquid level detection is disabled
		static variable DispenseMode(0);														// dispense mode (0 = jet mode empty tip, 1 = jet mode part volume, 2 = surface dispense part volume, 3 = surface dispense empty tip)
		static variable DispenseLiquidFollowing(hslTrue);								// liquid following during dispense and mix (0 = disabled, 1 = enabled)
		static variable DispensePrerinsingMixCycles(0);									// prerinsing / mix cycles 
		static variable DispensePrerinsingMixPosition(2);								// prerinsing / mix position [mm]
		static variable DispensePrerinsingMixVolume(0);									// prerinsing / mix volume [ul]
		static variable DispenseUserDefinedLiquidClass("");							// liquid class 
		static variable DispenseUserDefinedLiquidClasses[];							// liquid class name per sequence position in DispenseSequence 

		static function NumberOfActiveChannels(
			string& channelPattern)
		{
			variable index;
			variable length;
			variable numberOfActiveChannels(0);

			length = channelPattern.GetLength();
			for (index = 0; index < length; index++)
			{
				if ("1" == channelPattern.Mid(index, 1))
					numberOfActiveChannels++;
			}
			return(numberOfActiveChannels);
		}

		static function ReverseSequence(
			sequence& originalSequence,
			sequence& reverseSequence,
			variable start,
			variable copyCount,
			variable reverseCount)
		{
			variable index;
			variable count;
			variable currentPos;
			variable currentPosBak;

			// backup current position
			currentPosBak = originalSequence.GetCurrentPosition();

			// copy original sequence
			for (index = originalSequence.SetCurrentPosition(start); 
				  0 < index && index < start + copyCount; 
				  index = originalSequence.Increment(1))
				reverseSequence.Add(originalSequence.GetLabwareId(), originalSequence.GetPositionId());

			// reverse copy original sequence
			count = originalSequence.GetCount();
			currentPos = originalSequence.GetCurrentPosition();
			reverseCount = Util::Max(currentPos - 1, count - reverseCount);
			if (0 < reverseCount)
			{
				originalSequence.SetCurrentPosition(count);
				for (index = count; 
					  reverseCount < index; 
					  index = originalSequence.Increment(-1))
					reverseSequence.Add(originalSequence.GetLabwareId(), originalSequence.GetPositionId());
			}

			// restore current position
			originalSequence.SetCurrentPosition(currentPosBak);
			
			// set indexes of reverse sequence
			reverseSequence.SetCount(reverseSequence.GetTotal());
			reverseSequence.SetCurrentPosition(1);
			reverseSequence.SetMax(originalSequence.GetMax());

			return(hslTrue);
		}

		static function SetTipType(
			device& ML_STAR,
			sequence& tipPickupSequence)
		{
			// synthesize tip type out of labware contained in tipPickupSequence

			variable index;					// loop counter
			variable tipType("");			// tip type
			variable labwareId("");			// labware id
			variable currentPosBak;			// backup of current position
			variable propertyKeys[];		// place to hold property keys
			variable propertyValues[];		// place to hold property values

			// backup current position
			currentPosBak = tipPickupSequence.GetCurrentPosition();

			// iterate over labware contained in tipPickupSequence
			propertyKeys.AddAsLast(StringConstants::tipRackKey);
			for (index = tipPickupSequence.SetCurrentPosition(1); 
				  0 < index; 
				  index = tipPickupSequence.Increment(tipPickupSequence.GetPositionCountForCurrLabware()))
			{
				labwareId = tipPickupSequence.GetLabwareId();
				ML_STAR.GetLabwareData(labwareId, propertyKeys, propertyValues);
				if (0 < propertyValues.GetSize())
				{
					// found a labware supporting key MlStarTipRack
					variable propertyValue;
					propertyValue = propertyValues.GetAt(0);
					// without filter
					if (TipTypeNum::standardVolumeTip == propertyValue)
					{
						tipType = TipType::standardVolumeTip;
						break;
					}
					if (TipTypeNum::lowVolumeTip == propertyValue)
					{
						tipType = TipType::lowVolumeTip;
						break;
					}
					if (TipTypeNum::highVolumeTip == propertyValue)
					{
						tipType = TipType::highVolumeTip;
						break;
					}
					// with filter
					if (TipTypeNum::standardVolumeTipWithFilter == propertyValue)
					{
						tipType = TipType::standardVolumeTipWithFilter;
						break;
					}
					if (TipTypeNum::lowVolumeTipWithFilter == propertyValue)
					{
						tipType = TipType::lowVolumeTipWithFilter;
						break;
					}
					if (TipTypeNum::highVolumeTipWithFilter == propertyValue)
					{
						tipType = TipType::highVolumeTipWithFilter;
						break;
					}
				}
			}
			// restore current position 
			tipPickupSequence.SetCurrentPosition(currentPosBak);

			if ("" == tipType)
				// tip type not supported
				Error::Raise(IDE::invalidTipType, GetFileName(), GetFunctionName(), GetLineNumber());

			// set tip type
			TipPickupTipType = tipType;
		}

		static function TrackVolume(
			variable& worklistFileName,								// i: worklist file name
			variable& iterator[],										// i: iterator
			string& stepTypePattern)									// i: step type per channel, e.g. "AAAAAAAA" or "W W F F "
		{
			variable size;
			variable index;
			variable maxTipVolume(0);				// maximal tip volume 
			variable residualTipVolume(0);		// residual tip volume 
			variable currentTipVolume(0);			// current tip volume 
			variable currentPipVolume(0);			// current pipetting of volume 
			variable unknownTipType(hslTrue);

			// switch over tip type and restrict volume appropriate to the tip and step type 
			if (TipType::lowVolumeTip == TipPickupTipType)
			{
				maxTipVolume = TipVolume::low;
				unknownTipType = hslFalse;
			}
			if (TipType::standardVolumeTip == TipPickupTipType)
			{
				maxTipVolume = TipVolume::standard;
				unknownTipType = hslFalse;
			}
			if (TipType::highVolumeTip == TipPickupTipType)
			{
				maxTipVolume = TipVolume::high;
				unknownTipType = hslFalse;
			}
			if (TipType::lowVolumeTipWithFilter == TipPickupTipType)
			{
				maxTipVolume = TipVolume::lowWithFilter;
				unknownTipType = hslFalse;
			}
			if (TipType::standardVolumeTipWithFilter == TipPickupTipType)
			{
				maxTipVolume = TipVolume::standardWithFilter;
				unknownTipType = hslFalse;
			}
			if (TipType::highVolumeTipWithFilter == TipPickupTipType)
			{
				maxTipVolume = TipVolume::highWithFilter;
				unknownTipType = hslFalse;
			}

			if (unknownTipType)
				// unknown tip type
				Error::Raise(IDE::invalidTipType, GetFileName(), GetFunctionName(), GetLineNumber());

			// iterate over aspirate volumes
			size = PCB::AspirateVolumes.GetSize();
			for (index = 0; index < size; index++)
			{
				currentTipVolume = TipVolume::current.GetAt(index);
				currentPipVolume = PCB::AspirateVolumes.GetAt(index);
				residualTipVolume = maxTipVolume - currentTipVolume - currentPipVolume;
				#ifdef _DEBUG
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "TipVolume::current[", index + 1, "] = ", currentTipVolume);
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "PCB::AspirateVolumes[", index + 1, "] = ", currentPipVolume);
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "residualTipVolume[", index + 1, "] = ", residualTipVolume);
				#endif
				if (0 <= residualTipVolume && residualTipVolume <= maxTipVolume)
				{
					// positive residual tip volume,
					// track current tip volume
					TipVolume::current.SetAt(index, currentTipVolume + currentPipVolume);
				}
				else
				{
					// negative residual tip volume,
					// raise an error
					Error::Raise(IDE::invalidVolume, worklistFileName, "", IStr(iterator.GetAt(index)));
				}
			}

			// iterate over dispense volumes
			size = PCB::DispenseVolumes.GetSize();
			for (index = 0; index < size; index++)
			{
				currentTipVolume = TipVolume::current.GetAt(index);
				currentPipVolume = PCB::DispenseVolumes.GetAt(index);
				residualTipVolume = maxTipVolume - currentTipVolume + currentPipVolume;
				#ifdef _DEBUG
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "TipVolume::current[", index + 1, "] = ", currentTipVolume);
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "PCB::DispenseVolumes[", index + 1, "] = ", currentPipVolume);
				FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "residualTipVolume[", index + 1, "] = ", residualTipVolume);
				#endif
				if (0 <= residualTipVolume && residualTipVolume <= maxTipVolume)
				{
					// positive residual tip volume,
					// track current tip volume
					TipVolume::current.SetAt(index, currentTipVolume - currentPipVolume);
				}
				else
				{
					// negative residual tip volume,
					// raise an error
					Error::Raise(IDE::invalidVolume, worklistFileName, "", IStr(iterator.GetAt(index)));
				}
			}

			// reset tip volume if it's a Wash or Flush step
			if ("" == stepTypePattern.SpanExcluding("WF"))
			{
				// it's a Wash or Flush step,
				// iterate over current tip volumes
				size = TipVolume::current.GetSize();
				for (index = 0; index < size; index++)
				{
					// track current tip volume
					TipVolume::current.SetAt(index, 0);
				}
			}
		}

		static function SetDefaultWaste(
			device& ML_STAR,
			string& channelPattern)
		{
			// set default for waste sequences
			variable numberOfChannels;
			numberOfChannels = channelPattern.GetLength();
			if (!ML_STAR.GetSequenceRef(ML_STAR.GetCfgValueWithKey(MlStarCfgKey::defaultWaste), InitializeWasteDestination))
			{
				// desired deck sequence was not found
				ML_STAR.GetSequenceRef(ML_STAR.Waste.GetName(), InitializeWasteDestination);
				if (InitializeWasteDestination.GetCount() < numberOfChannels)
					ML_STAR.GetSequenceRef(ML_STAR.Waste16.GetName(), InitializeWasteDestination);
			}
			if (!ML_STAR.GetSequenceRef(ML_STAR.GetCfgValueWithKey(MlStarCfgKey::defaultWaste), TipEjectWasteDestination))
			{
				// desired deck sequence was not found
				ML_STAR.GetSequenceRef(ML_STAR.Waste.GetName(), TipEjectWasteDestination);
				if (TipEjectWasteDestination.GetCount() < numberOfChannels)
					ML_STAR.GetSequenceRef(ML_STAR.Waste16.GetName(), TipEjectWasteDestination);
			}
		}

		static function SetLiquidClass(
			variable& liquidClassName)
		{
			variable index;
			file liquidClassFile;								// handle to  file containing extended liquid class information
			variable liquidClassFileName;						// name of file containing extended liquid class information
			variable liquidClassFilePathName;				// path and name of file containing extended liquid class information
			variable unformatedErrorDesc;						// place to hold unformated error description
			variable errorDesc;									// place to hold formated error description

			// open file containing extended liquid class information,
			// This is an ASCII text file, located in the Phoenix Config directory, which has the 
			// same name as the liquid class and the extension .csv. The values are comma separated.
			if ("" != liquidClassName)
			{
				liquidClassFileName = GetConfigPath() + "\\" + liquidClassName + StringConstants::liquidClassFileExt;

				// search the file containing extended liquid class information,
				liquidClassFilePathName = SearchPath(liquidClassFileName);
				if ("" == liquidClassFilePathName)
				{
					errorDesc = StringTable::Load(IDE::fileNotFound);
					StrReplace(errorDesc, "%s", liquidClassFileName);
					Error::RaiseEx(IDE::fileNotFound, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				}

				// open file containing extended liquid class information
				liquidClassFile.SetDelimiter(StringConstants::liquidClassDelimiter);
				liquidClassFile.AddField("AspirateMode", AspirateMode, hslInteger);
				liquidClassFile.AddField("AspirateCLLDSensitivity", AspirateCLLDSensitivity, hslInteger);
				liquidClassFile.AddField("AspirateFluidHeight", AspirateFluidHeight, hslFloat);
				liquidClassFile.AddField("AspirateSubmergeDepth", AspirateSubmergeDepth, hslFloat);
				liquidClassFile.AddField("AspirateMaxHeightDiff", AspirateMaxHeightDiff, hslFloat);
				liquidClassFile.AddField("AspiratePLLDSensitivity", AspiratePLLDSensitivity, hslInteger);
				liquidClassFile.AddField("AspirateLiquidFollowing", AspirateLiquidFollowing, hslInteger);
				liquidClassFile.AddField("AspiratePrerinsingMixCycles", AspiratePrerinsingMixCycles, hslInteger);
				liquidClassFile.AddField("AspiratePrerinsingMixPosition", AspiratePrerinsingMixPosition, hslFloat);
				liquidClassFile.AddField("AspiratePrerinsingMixVolume", AspiratePrerinsingMixVolume, hslFloat);
				liquidClassFile.AddField("DispenseSubmergeDepth", DispenseSubmergeDepth, hslFloat);
				liquidClassFile.AddField("DispenseCLLDSensitivity", DispenseCLLDSensitivity, hslInteger);
				liquidClassFile.AddField("DispenseFluidHeight", DispenseFluidHeight, hslFloat);
				liquidClassFile.AddField("DispenseMode", DispenseMode, hslInteger);
				liquidClassFile.AddField("DispenseLiquidFollowing", DispenseLiquidFollowing, hslInteger);
				liquidClassFile.AddField("DispensePrerinsingMixCycles", DispensePrerinsingMixCycles, hslInteger);
				liquidClassFile.AddField("DispensePrerinsingMixPosition", DispensePrerinsingMixPosition, hslFloat);
				liquidClassFile.AddField("DispensePrerinsingMixVolume", DispensePrerinsingMixVolume, hslFloat);
				if (!liquidClassFile.Open(liquidClassFilePathName, hslRead))
				{
					errorDesc = StringTable::Load(IDE::fileOpenFailed);
					StrReplace(errorDesc, "%s", liquidClassFilePathName);
					Error::RaiseEx(IDE::fileOpenFailed, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				}

				// read the extended liquid class information
				liquidClassFile.ReadRecord();

				// check values read to be valid
				unformatedErrorDesc = StringTable::Load(IDE::invalidLiquidClassValue);
				errorDesc = unformatedErrorDesc;
				StrReplace(errorDesc, "%s", "AspirateMode");
				if (!Util::IsNumber(AspirateMode))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!Util::IsInteger(AspirateMode))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (AspirateMode < 0 || 2 < AspirateMode)
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());

				errorDesc = unformatedErrorDesc;
				StrReplace(errorDesc, "%s", "AspirateCLLDSensitivity");
				if (!Util::IsNumber(AspirateCLLDSensitivity))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!Util::IsInteger(AspirateCLLDSensitivity))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (AspirateCLLDSensitivity < LLDSensitivity::first || LLDSensitivity::last < AspirateCLLDSensitivity)
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());

				errorDesc = unformatedErrorDesc;
				StrReplace(errorDesc, "%s", "AspirateFluidHeight");
				if (!Util::IsNumber(AspirateFluidHeight))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (Util::IsNegative(AspirateFluidHeight))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());

				errorDesc = unformatedErrorDesc;
				StrReplace(errorDesc, "%s", "AspirateSubmergeDepth");
				if (!Util::IsNumber(AspirateSubmergeDepth))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());

				errorDesc = unformatedErrorDesc;
				StrReplace(errorDesc, "%s", "AspirateMaxHeightDiff");
				if (!Util::IsNumber(AspirateMaxHeightDiff))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (Util::IsNegative(AspirateMaxHeightDiff))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());

				errorDesc = unformatedErrorDesc;
				StrReplace(errorDesc, "%s", "AspiratePLLDSensitivity");
				if (!Util::IsNumber(AspiratePLLDSensitivity))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!Util::IsInteger(AspiratePLLDSensitivity))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (AspiratePLLDSensitivity < LLDSensitivity::first || LLDSensitivity::last < AspiratePLLDSensitivity)
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());

				errorDesc = unformatedErrorDesc;
				StrReplace(errorDesc, "%s", "AspirateLiquidFollowing");
				if (!Util::IsNumber(AspirateLiquidFollowing))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (Util::IsFloat(AspirateLiquidFollowing))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (AspirateLiquidFollowing < 0 || 1 < AspirateLiquidFollowing)
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());

				errorDesc = unformatedErrorDesc;
				StrReplace(errorDesc, "%s", "AspiratePrerinsingMixCycles");
				if (!Util::IsNumber(AspiratePrerinsingMixCycles))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!Util::IsInteger(AspiratePrerinsingMixCycles))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (Util::IsNegative(AspiratePrerinsingMixCycles))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());

				errorDesc = unformatedErrorDesc;
				StrReplace(errorDesc, "%s", "AspiratePrerinsingMixPosition");
				if (!Util::IsNumber(AspiratePrerinsingMixPosition))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (Util::IsNegative(AspiratePrerinsingMixPosition))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());

				errorDesc = unformatedErrorDesc;
				StrReplace(errorDesc, "%s", "AspiratePrerinsingMixVolume");
				if (!Util::IsNumber(AspiratePrerinsingMixVolume))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (Util::IsNegative(AspiratePrerinsingMixVolume))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());

				errorDesc = unformatedErrorDesc;
				StrReplace(errorDesc, "%s", "DispenseSubmergeDepth");
				if (!Util::IsNumber(DispenseSubmergeDepth))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());

				errorDesc = unformatedErrorDesc;
				StrReplace(errorDesc, "%s", "DispenseCLLDSensitivity");
				if (!Util::IsNumber(DispenseCLLDSensitivity))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!Util::IsInteger(DispenseCLLDSensitivity))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (DispenseCLLDSensitivity < LLDSensitivity::first || LLDSensitivity::last < DispenseCLLDSensitivity)
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());

				errorDesc = unformatedErrorDesc;
				StrReplace(errorDesc, "%s", "DispenseFluidHeight");
				if (!Util::IsNumber(DispenseFluidHeight))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (Util::IsNegative(DispenseFluidHeight))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());

				errorDesc = unformatedErrorDesc;
				StrReplace(errorDesc, "%s", "DispenseMode");
				if (!Util::IsNumber(DispenseMode))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!Util::IsInteger(DispenseMode))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (DispenseMode < 0 || 3 < DispenseMode)
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());

				errorDesc = unformatedErrorDesc;
				StrReplace(errorDesc, "%s", "DispenseLiquidFollowing");
				if (!Util::IsNumber(DispenseLiquidFollowing))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (Util::IsFloat(DispenseLiquidFollowing))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (DispenseLiquidFollowing < 0 || 1 < DispenseLiquidFollowing)
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());

				errorDesc = unformatedErrorDesc;
				StrReplace(errorDesc, "%s", "DispensePrerinsingMixCycles");
				if (!Util::IsNumber(DispensePrerinsingMixCycles))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (!Util::IsInteger(DispensePrerinsingMixCycles))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (Util::IsNegative(DispensePrerinsingMixCycles))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());

				errorDesc = unformatedErrorDesc;
				StrReplace(errorDesc, "%s", "DispensePrerinsingMixPosition");
				if (!Util::IsNumber(DispensePrerinsingMixPosition))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (Util::IsNegative(DispensePrerinsingMixPosition))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());

				errorDesc = unformatedErrorDesc;
				StrReplace(errorDesc, "%s", "DispensePrerinsingMixVolume");
				if (!Util::IsNumber(DispensePrerinsingMixVolume))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
				if (Util::IsNegative(DispensePrerinsingMixVolume))
					Error::RaiseEx(IDE::invalidLiquidClassValue, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
			}
		}

		static function ResetPipettingStateAndSequences(
			variable resetAll)
		{

			// general settings 

			if (resetAll)
			{
				UserResponseTime = NumberConstants::userResponseTime;		// user response time [s]
				ErrorHandling = ErrorHandling::continue;						// error handling (1 = abort method, 2 = cancel step, 3 = ignore and continue)
				TipCountingEnabled = hslFalse;									// tip counting enabled flag
				TipCountingIdentifier = StringConstants::tipCountingId;	// tip count identifier
			}

			// initialize settings 

			if (resetAll)
			{
				InitializeUseDefaultWaste = hslTrue;							// indicates whether to use the default waste (0 = off, 1 = on)
				InitializeSequenceCounting = 0;									// sequence counting (0 = manually, 1 = automatic)
				InitializeChannelUse = 1;											// channel use (1 = all sequence positions, 2 = channel pattern)
				InitializeAlways = hslFalse;										// initialize always flag
				InitializeEnabled = hslTrue;										// initialize enabled flag (0 = disabled, 1 = enabled)
			}
			SeqRemoveAll(InitializeWasteDestination);							// initialize waste destination
			InitializeChannelVariable = "";										// channel variable (0 = unused, 1 = used)

			// tip pickup settings 

			if (resetAll)
			{
				TipPickupSequenceCounting = 0;									// sequence counting (0 = manually, 1 = automatic)
				TipPickupChannelUse = 1;											// channel use (1 = all sequence positions, 2 = channel pattern)
				TipPickupEnabled = hslTrue;										// tip pickup enabled flag (0 = disabled, 1 = enabled)
				TipPickupReverseSequenceCount = NumberConstants::reverseSequenceCount;// count of reverse tip pickup sequence
			}
			SeqRemoveAll(TipPickupSequence);										// original tip pickup sequence
			TipPickupTipType = "";													// tip type
			TipPickupNow = hslTrue;													// tip pickup now flag (0 = deferred, 1 = now)
			TipPickupChannelVariable = "";										// channel variable (0 = unused, 1 = used)

			// tip eject settings 

			if (resetAll)
			{
				TipEjectUseDefaultWaste = hslTrue;								// indicates whether to use the default waste (0 = off, 1 = on)
				TipEjectChannelUse = 1;												// channel use (1 = all sequence positions, 2 = channel pattern)
				TipEjectSequenceCounting = 0;										// sequence counting (0 = manually, 1 = automatic)
			}
			SeqRemoveAll(TipEjectWasteDestination);							// tip eject waste destination
			TipEjectChannelVariable = "";											// channel variable (0 = unused, 1 = used)

			// aspirate settings 

			if (resetAll)
			{
				AspirateSequenceCounting = 0;										// sequence counting (0 = manually, 1 = automatic)
				AspirateChannelUse = 1;												// channel use (1 = all sequence positions, 2 = channel pattern)
				AspirateMode = 0;														// aspirate mode (0 = aspiration, 1 = consecutive aspiration, 2 = empty cup aspiration)
				AspirateCLLDSensitivity = 0;										// capacitive liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
				AspirateFluidHeight = 0;											// liquid height from bottom if liquid level detection is disabled
				AspirateSubmergeDepth = 2;											// submerge depth after the liquid level detection [mm]
				AspirateMaxHeightDiff = 0;											// the maximum difference between the two liquid level detection measurements [mm]
				AspiratePLLDSensitivity = 0;										// pressure liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
				AspirateLiquidFollowing = hslTrue;								// liquid following during aspirate and mix (0 = disabled, 1 = enabled)
				AspiratePrerinsingMixCycles = 0;									// prerinsing / mix cycles 
				AspiratePrerinsingMixPosition = 2;								// prerinsing / mix position [mm]
				AspiratePrerinsingMixVolume = 0;									// prerinsing / mix volume [ul]
			}
			SeqRemoveAll(AspirateSequence);										// aspirate sequence
			AspirateVolumes.SetSize(0);											// aspirate volume per channel [ul]
			AspirateChannelVariable = "";											// channel variable (0 = unused, 1 = used)
			AspirateUserDefinedLiquidClass = "";								// liquid class name 
			AspirateUserDefinedLiquidClasses.SetSize(0);						// liquid class name per sequence position in AspirateSequence 

			// dispense settings 

			if (resetAll)
			{
				DispenseSubmergeDepth = 2;											// submerge depth after the liquid level detection [mm]
				DispenseRestVolumeDestination = 0;								// dispense rest volume destination (0 = waste, 1 = aspirate sequence)
				DispenseRestVolumeFluidHeight = 10;								// liquid height from bottom to dispense rest volume [mm]
				DispenseChannelUse = 1;												// channel use (1 = all sequence positions, 2 = channel pattern)
				DispenseCLLDSensitivity = 0;										// capacitive liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
				DispenseSequenceCounting = 0;										// sequence counting (0 = manually, 1 = automatic)
				DispenseFluidHeight = 0;											// liquid height from bottom if liquid level detection is disabled
				DispenseMode = 0;														// dispense mode (0 = jet mode empty tip, 1 = jet mode part volume, 2 = surface dispense part volume, 3 = surface dispense empty tip)
				DispenseLiquidFollowing = hslTrue;								// liquid following during dispense and mix (0 = disabled, 1 = enabled)
				DispensePrerinsingMixCycles = 0;									// prerinsing / mix cycles 
				DispensePrerinsingMixPosition = 2;								// prerinsing / mix position [mm]
				DispensePrerinsingMixVolume = 0;									// prerinsing / mix volume [ul]
			}
			SeqRemoveAll(DispenseSequence);										// dispense sequence
			DispenseVolumes.SetSize(0);											// dispense volume per channel [ul]
			DispenseChannelVariable = "";											// channel variable (0 = unused, 1 = used)
			DispenseUserDefinedLiquidClass = "";								// liquid class name 
			DispenseUserDefinedLiquidClasses.SetSize(0);						// liquid class name per sequence position in DispenseSequence 
		}

		static function ToggleChannel(
			string& channelPattern,
			variable channel)
		{
			string left("");									// place to hold left part of channelPattern
			string mid("");									// place to hold mid part of channelPattern
			string right("");									// place to hold right part of channelPattern
			variable length;

			length = channelPattern.GetLength();
			if (channel - 1 <= length)
				left = channelPattern.Left(channel - 1);
			if (channel - 1 <= length)
				mid = channelPattern.Mid(channel - 1, 1);
			if (channel <= length)
				right = channelPattern.Mid(channel, Global::maxNumberOfChannels);
			if (mid.Compare("1") == 0)
				// clear the bit for this channel in the channel pattern
				channelPattern = left + "0";
			else
				// set the bit for this channel in the channel pattern
				channelPattern = left + "1";
			channelPattern = channelPattern + right;
		}

		static function ClearChannel(
			string& channelPattern,
			variable channel)
		{
			string left("");									// place to hold left part of channelPattern
			string mid("");									// place to hold mid part of channelPattern
			string right("");									// place to hold right part of channelPattern
			variable length;

			length = channelPattern.GetLength();
			if (channel - 1 <= length)
				left = channelPattern.Left(channel - 1);
			if (channel - 1 <= length)
				mid = channelPattern.Mid(channel - 1, 1);
			if (channel <= length)
				right = channelPattern.Mid(channel, Global::maxNumberOfChannels);
			// clear the bit for this channel in the channel pattern
			channelPattern = left + "0";
			channelPattern = channelPattern + right;
		}

		static function InitPipettingDevice(
			device& ML_STAR)
		{
			variable rc[];																		// step return 
			
			// initialize the pipetting device once only
			if (InitializeEnabled && TipPickupEnabled)
			{
				variable instrumentName;													// instrument name 
				variable arrIndex;															// an array index

				// activate error handler
				onerror goto Unexpected;

				// get access to global data
				SynEnterCriticalSection(hslML_STARLibCs);

				// check if the instrument has already been initialized
				instrumentName = ML_STAR.GetInstrumentName();
				if (!Util::Lookup(hslML_STARLibInitializedPipettingDevices, instrumentName, arrIndex))
				{
					// the instrument hasn't already been initialized,

					// release access to global data
					SynLeaveCriticalSection(hslML_STARLibCs);

					// deactivate error handler
					onerror goto 0;

					// debug
					#ifdef _DEBUG
					if (InitializeUseDefaultWaste)
						FormatTrace("DEBUG", "ML_STAR.Initialize", TraceStatus::progress, 
										"useDefaultWaste = ", InitializeUseDefaultWaste);
					else
						FormatTrace("DEBUG", "ML_STAR.Initialize", TraceStatus::progress, 
										"useDefaultWaste = ", InitializeUseDefaultWaste, 
										", name = ", InitializeWasteDestination.GetName(), 
										", current = ", InitializeWasteDestination.GetCurrentPosition(), 
										", count = ", InitializeWasteDestination.GetCount(),
										", maxPos = ", InitializeWasteDestination.GetMax());
					#endif

					// initialize
					onerror goto InitializeErrorHandler;
					rc = MlStar::StepInitialize(	ML_STAR,
															InitializeUseDefaultWaste,
															InitializeWasteDestination,
															InitializeSequenceCounting,
															InitializeChannelVariable,
															InitializeChannelUse,
															InitializeAlways,
															ErrorHandling,
															UserResponseTime);
					onerror goto 0;
					if (!StepReturn::EvaluateEx(ML_STAR, rc, InitializeChannelVariable))
						Error::RaiseLast();
					InitializeEnabled = hslFalse;

					// activate error handler
					onerror goto Unexpected;

					// get access to global data
					SynEnterCriticalSection(hslML_STARLibCs);

					// add the instrument to the collection holding the initialized devices,
					hslML_STARLibInitializedPipettingDevices.AddAsLast(instrumentName);

					// release access to global data
					SynLeaveCriticalSection(hslML_STARLibCs);

					// deactivate error handler
					onerror goto 0;
				}

				// release access to global data
				SynLeaveCriticalSection(hslML_STARLibCs);

				// deactivate error handler
				onerror goto 0;
			}
			return(rc);

			InitializeErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}

			Unexpected:
			{
				// release access to global data
				SynLeaveCriticalSection(hslML_STARLibCs);
				Error::RaiseLast();
			}
		}

		static function PickupPipettingTips(
			device& ML_STAR,
			sequence& tipPickupSequence)
		{
			variable rc[];																				// step return 

			// activate error handler
			onerror goto Unexpected;

			// if tip pickup is enabled and is not deferred we pickup new tips
			if (TipPickupEnabled && TipPickupNow)
			{
				// Remark:
				// To keep the shape of the tip pickup sequence optimal if tips are used in 
				// the error handling, the tip pickup sequence is partially reversed. The 
				// first copyCount positions are copied from the begin of the original tip 
				// pickup sequence and the remaining TipPickupReverseSequenceCount are copied 
				// in reverse order from the end of the original tip pickup sequence.

				variable copyCount(0);						// number of positions to copy
				variable currentPos(0);						// current position
				variable numberOfActiveChannels(0);		// number of active channels
				variable availablePositions(0);			// number of available positions 
				variable maxPositionsPerStep(0);			// max number of positions per step
				variable usedPositions(0);					// number of used positions 
				sequence reverseTipPickupSequence;		// place to hold reverses order of positions of the tip pickup sequence
				variable canceledByTheUser(hslFalse);	// indicates whether an error recovery has been canceled by the user

				// determine tip pickup constraints 
				numberOfActiveChannels = NumberOfActiveChannels(TipPickupChannelVariable);
				maxPositionsPerStep = tipPickupSequence.GetMax();
				currentPos = tipPickupSequence.GetCurrentPosition();
				if (0 < currentPos)
					availablePositions = tipPickupSequence.GetCount() - currentPos + 1;
				copyCount = Util::Min(numberOfActiveChannels, Util::Min(maxPositionsPerStep, availablePositions));

				// reverse tip pickup sequence
				ReverseSequence(tipPickupSequence, reverseTipPickupSequence, 
									 tipPickupSequence.GetCurrentPosition(), copyCount, TipPickupReverseSequenceCount);

				// debug
				#ifdef _DEBUG
				FormatTrace("DEBUG", "ML_STAR.TipPickUp", TraceStatus::progress,
								"name = ", tipPickupSequence.GetName(), 
								", current = ", tipPickupSequence.GetCurrentPosition(), 
								", count = ", tipPickupSequence.GetCount(),
								", maxPos = ", tipPickupSequence.GetMax(),
								", TipPickupChannelVariable = ", TipPickupChannelVariable);
				#endif

				// pickup new tips (from reverseTipPickupSequence)
				onerror goto TipPickUpErrorHandler;
				rc = MlStar::StepTipPickup(ML_STAR,
													reverseTipPickupSequence,
													TipPickupSequenceCounting,
													TipPickupChannelVariable,
													TipPickupChannelUse,
													ErrorHandling,
													UserResponseTime);
				onerror goto Unexpected;

				// reset TipPickupNow control setting
				TipPickupNow = hslFalse;

				// evaluate step return
				if (!StepReturn::EvaluateEx(ML_STAR, rc, TipPickupChannelVariable))
					canceledByTheUser = hslTrue;

				// increment tip pickup sequence 
				if (0 == TipPickupSequenceCounting)
					// manual sequence counting
					tipPickupSequence.Increment(copyCount);

				// get number of used positions and update the count of the tip pickup sequence
				usedPositions = reverseTipPickupSequence.GetUsedPositions();
				if (copyCount < usedPositions)
					tipPickupSequence.SetCount(tipPickupSequence.GetCount() - usedPositions + copyCount);

				// if tip counting is enabled, write indexes of tipPickupSequence to file
				if (TipCountingEnabled)
					TipCount::Write(tipPickupSequence, TipCountingIdentifier);

				// check if an error recovery has been canceled by the user
				if (canceledByTheUser)
					// re-throw error
					Error::RaiseLast();
			}
			return(rc);

			TipPickUpErrorHandler:
			{
				// if tip counting is enabled, write indexes of tipPickupSequence to file
				if (TipCountingEnabled)
					TipCount::Write(tipPickupSequence, TipCountingIdentifier);

				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}

			Unexpected:
			{
				// if tip counting is enabled, write indexes of tipPickupSequence to file
				if (TipCountingEnabled)
					TipCount::Write(tipPickupSequence, TipCountingIdentifier);

				// re-throw error
				Error::RaiseLast();
			}
		}

		static function EjectPipettingTips(
			device& ML_STAR)
		{
			variable rc[];																// step return 

			// if tip pickup is enabled we eject the tips
			if (TipPickupEnabled)
			{
				#ifdef _DEBUG
				FormatTrace("DEBUG", "ML_STAR.TipEject", TraceStatus::progress,
								"name = ", TipEjectWasteDestination.GetName(), 
								", current = ", TipEjectWasteDestination.GetCurrentPosition(), 
								", count = ", TipEjectWasteDestination.GetCount(),
								", maxPos = ", TipEjectWasteDestination.GetMax(),
								", TipEjectChannelVariable = ", TipEjectChannelVariable);
				#endif

				// eject the tips
				onerror goto TipEjectErrorHandler;
				rc = MlStar::StepTipEject(	ML_STAR,
													TipEjectUseDefaultWaste,
													TipEjectWasteDestination,
													TipEjectSequenceCounting,
													TipEjectChannelVariable,
													TipEjectChannelUse,
													ErrorHandling,
													UserResponseTime);
				onerror goto 0;

				// set TipPickupNow control setting
				TipPickupNow = hslTrue;

				// evaluate step return
				if (!StepReturn::EvaluateEx(ML_STAR, rc, TipEjectChannelVariable))
					Error::RaiseLast();
			}

			return(rc);

			TipEjectErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}
		}

		static function TransferLiquid(
			device& ML_STAR,
			sequence& tipPickupSequence)
		{
			variable rc[];											// step return array 
			variable liquidClassName;							// current liquid class name

			if (0 < AspirateSequence.GetCount())
			{

				// set liquid class
				liquidClassName = AspirateUserDefinedLiquidClasses.ElementAt(0);
				if (AspirateUserDefinedLiquidClass != liquidClassName)
				{
					PCB::SetLiquidClass(liquidClassName);
					AspirateUserDefinedLiquidClass = liquidClassName;
					DispenseUserDefinedLiquidClass = liquidClassName;
				}

				// aspirate volume 
				#ifdef _DEBUG
				{
				variable index;
				variable size;
				FormatTrace("DEBUG", "ML_STAR.Aspirate", TraceStatus::progress,
								"name = ", AspirateSequence.GetName(), 
								", current = ", AspirateSequence.GetCurrentPosition(), 
								", count = ", AspirateSequence.GetCount(),
								", maxPos = ", AspirateSequence.GetMax(),
								", AspirateChannelVariable = ", AspirateChannelVariable,
								", AspirateUserDefinedLiquidClass = ", AspirateUserDefinedLiquidClass);
				size = AspirateVolumes.GetSize();
				for (index = 0; index < size; index++)
					FormatTrace("DEBUG", "ML_STAR.Aspirate", TraceStatus::progress,
									"AspirateVolumes[", index, "] = ", AspirateVolumes.GetAt(index));
				//MessageBox("DebugBreak", "Aspirate");
				}
				#endif
				onerror goto AspirateErrorHandler;
				rc = MlStar::StepAspirateEx(	ML_STAR,
														AspirateSequence,
														AspirateSequenceCounting,
														AspirateVolumes,
														AspirateMode,
														AspirateCLLDSensitivity,
														AspiratePLLDSensitivity,
														AspirateSubmergeDepth,
														AspirateFluidHeight,
														AspirateMaxHeightDiff,
														AspirateChannelVariable,
														AspirateChannelUse,
														AspirateLiquidFollowing,
														AspiratePrerinsingMixCycles,
														AspiratePrerinsingMixPosition,
														AspiratePrerinsingMixVolume,
														AspirateUserDefinedLiquidClass,
														ErrorHandling,
														UserResponseTime);
				onerror goto 0;

				// evaluate step return
				if (!StepReturn::EvaluateEx(ML_STAR, rc, AspirateChannelVariable))
				{
					// Note: We don't have neither the CopyPatternEnabled nor the ExcludeErrorPositionsEnabled
					// option, so we don't have to replace the erroneous tip via the StepReturn::HandleError function.
					//StepReturn::HandleError(ML_STAR, tipPickupSequence, StepReturn::StepType::aspirate);
					Error::RaiseLast();
				}
				StepReturn::Empty(rc);
			}


			if (0 < DispenseSequence.GetCount())
			{
				// set liquid class
				liquidClassName = DispenseUserDefinedLiquidClasses.ElementAt(0);
				if (DispenseUserDefinedLiquidClass != liquidClassName)
				{
					PCB::SetLiquidClass(liquidClassName);
					DispenseUserDefinedLiquidClass = liquidClassName;
					AspirateUserDefinedLiquidClass = liquidClassName;
				}

				// dispense volume 
				#ifdef _DEBUG
				{
				variable index;
				variable size;
				FormatTrace("DEBUG", "ML_STAR.Dispense", TraceStatus::progress, 
								"name = ", DispenseSequence.GetName(), 
								", current = ", DispenseSequence.GetCurrentPosition(), 
								", count = ", DispenseSequence.GetCount(),
								", maxPos = ", DispenseSequence.GetMax(),
								", DispenseChannelVariable = ", DispenseChannelVariable,
								", DispenseUserDefinedLiquidClass = ", DispenseUserDefinedLiquidClass);
				size = DispenseVolumes.GetSize();
				for (index = 0; index < size; index++)
					FormatTrace("DEBUG", "ML_STAR.Dispense", TraceStatus::progress,
									"DispenseVolumes[", index, "] = ", DispenseVolumes.GetAt(index));
				//MessageBox("DebugBreak", "Dispense volume");
				}
				#endif
				onerror goto DispenseErrorHandler;
				rc = MlStar::StepDispenseEx(	ML_STAR,
														DispenseSequence,
														DispenseSequenceCounting,
														DispenseVolumes,
														DispenseMode,
														DispenseCLLDSensitivity,
														DispenseSubmergeDepth,
														DispenseFluidHeight,
														DispenseChannelVariable,
														DispenseChannelUse,
														DispenseLiquidFollowing,
														DispensePrerinsingMixCycles,
														DispensePrerinsingMixPosition,
														DispensePrerinsingMixVolume,
														DispenseUserDefinedLiquidClass,
														ErrorHandling,
														UserResponseTime);
				onerror goto 0;

				// evaluate step return
				if (!StepReturn::EvaluateEx(ML_STAR, rc, DispenseChannelVariable))
				{
					// Note: We don't have neither the CopyPatternEnabled nor the ExcludeErrorPositionsEnabled
					// option, so we don't have to replace the erroneous tip via the StepReturn::HandleError function.
					//StepReturn::HandleError(ML_STAR, tipPickupSequence, StepReturn::StepType::dispense);
					Error::RaiseLast();
				}
				StepReturn::Empty(rc);
			}

			return(rc);

			AspirateErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}

			DispenseErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}
		}

		static function FlushLiquid(
			device& ML_STAR,
			sequence& tipPickupSequence)
		{
			variable rc[];											// step return array 
			variable liquidClassName("");						// current liquid class name

			// dispense rest volume (if necessary)
			if (0 < PCB::DispenseSequence.GetCount())
			{
				// set liquid class
				liquidClassName = DispenseUserDefinedLiquidClasses.ElementAt(0);
				if (DispenseUserDefinedLiquidClass != liquidClassName)
				{
					PCB::SetLiquidClass(liquidClassName);
					DispenseUserDefinedLiquidClass = liquidClassName;
					AspirateUserDefinedLiquidClass = liquidClassName;
				}

				// dispense rest volume back to DispenseRestVolumeDestination
				// Dispense mode: Jet mode empty tip
				// Fixed height from bottom: DispenseRestVolumeFluidHeight
				// Liquid following: On
				#ifdef _DEBUG
				{
				variable index;
				variable size;
				FormatTrace("DEBUG", "ML_STAR.Dispense", TraceStatus::progress, 
								"name = ", DispenseSequence.GetName(), 
								", current = ", DispenseSequence.GetCurrentPosition(), 
								", count = ", DispenseSequence.GetCount(),
								", maxPos = ", DispenseSequence.GetMax(),
								", DispenseChannelVariable = ", DispenseChannelVariable,
								", DispenseUserDefinedLiquidClass = ", DispenseUserDefinedLiquidClass);
				size = DispenseVolumes.GetSize();
				for (index = 0; index < size; index++)
					FormatTrace("DEBUG", "ML_STAR.Dispense", TraceStatus::progress,
									"DispenseVolumes[", index, "] = ", DispenseVolumes.GetAt(index));
				//MessageBox("DebugBreak", "Dispense rest volume");
				}
				#endif
				onerror goto DispenseErrorHandler;
				rc = MlStar::StepDispenseEx(	ML_STAR,
														DispenseSequence,
														0,												// sequence counting (0 = manually, 1 = automatic)
														DispenseVolumes,
														0,												// dispense mode (0 = jet mode empty tip, 1 = jet mode part volume, 2 = surface dispense part volume, 3 = surface dispense empty tip)
														0,												// capacitive liquid level detection (0 = off, 1 = very high, 2 = high, 3 = middle, 4 = low)
														0,												// submerge depth after the liquid level detection [mm]
														DispenseRestVolumeFluidHeight,
														DispenseChannelVariable,
														1,												// channel use (1 = all sequence positions, 2 = channel pattern)
														1,												// liquid following during dispense and mix (0 = disabled, 1 = enabled)
														0,												// prerinsing / mix cycles 
														0,												// prerinsing / mix position [mm]
														0,												// prerinsing / mix volume [ul]
														DispenseUserDefinedLiquidClass,
														ErrorHandling,
														UserResponseTime);
				onerror goto 0;

				// evaluate step return
				if (!StepReturn::EvaluateEx(ML_STAR, rc, DispenseChannelVariable))
				{
					// Note: We don't have neither the CopyPatternEnabled nor the ExcludeErrorPositionsEnabled
					// option, so we don't have to replace the erroneous tip via the StepReturn::HandleError function.
					//StepReturn::HandleError(ML_STAR, tipPickupSequence, StepReturn::StepType::dispense);
					Error::RaiseLast();
				}
				StepReturn::Empty(rc);
			}

			return(rc);

			DispenseErrorHandler:
			{
				// bind error data
				StepReturn::Bind(rc);
				resume next;
			}
		}

		static function Dump()
		{
			#ifdef _DEBUG
			variable source;
			variable action;
			variable index;
			variable size;

			source = "DEBUG";
			action = GetFunctionName();

			// general settings 
			FormatTrace(source, action, TraceStatus::progress, "UserResponseTime = ", UserResponseTime);
			FormatTrace(source, action, TraceStatus::progress, "ErrorHandling = ", ErrorHandling);
			FormatTrace(source, action, TraceStatus::progress, "TipCountingEnabled = ", TipCountingEnabled);
			FormatTrace(source, action, TraceStatus::progress, "TipCountingIdentifier = ", TipCountingIdentifier);

			// initialize settings 
			FormatTrace(source, action, TraceStatus::progress, "InitializeUseDefaultWaste = ", InitializeUseDefaultWaste);
			FormatTrace(source, action, TraceStatus::progress, "InitializeWasteDestination.name = ", InitializeWasteDestination.GetName());
			FormatTrace(source, action, TraceStatus::progress, "InitializeWasteDestination.current = ", InitializeWasteDestination.GetCurrentPosition());
			FormatTrace(source, action, TraceStatus::progress, "InitializeWasteDestination.count = ", InitializeWasteDestination.GetCount());
			FormatTrace(source, action, TraceStatus::progress, "InitializeWasteDestination.total = ", InitializeWasteDestination.GetTotal());
			FormatTrace(source, action, TraceStatus::progress, "InitializeWasteDestination.maxPos = ", InitializeWasteDestination.GetMax());
			FormatTrace(source, action, TraceStatus::progress, "InitializeSequenceCounting = ", InitializeSequenceCounting);
			FormatTrace(source, action, TraceStatus::progress, "InitializeChannelUse = ", InitializeChannelUse);
			FormatTrace(source, action, TraceStatus::progress, "InitializeAlways = ", InitializeAlways);
			FormatTrace(source, action, TraceStatus::progress, "InitializeEnabled = ", InitializeEnabled);

			// tip pickup settings 
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequence.name = ", TipPickupSequence.GetName());
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequence.current = ", TipPickupSequence.GetCurrentPosition());
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequence.count = ", TipPickupSequence.GetCount());
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequence.total = ", TipPickupSequence.GetTotal());
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequence.maxPos = ", TipPickupSequence.GetMax());
			FormatTrace(source, action, TraceStatus::progress, "TipPickupSequenceCounting = ", TipPickupSequenceCounting);
			FormatTrace(source, action, TraceStatus::progress, "TipPickupTipType = ", TipPickupTipType);
			FormatTrace(source, action, TraceStatus::progress, "TipPickupChannelUse = ", TipPickupChannelUse);
			FormatTrace(source, action, TraceStatus::progress, "TipPickupEnabled = ", TipPickupEnabled);
			FormatTrace(source, action, TraceStatus::progress, "TipPickupNow = ", TipPickupNow);
			FormatTrace(source, action, TraceStatus::progress, "TipPickupReverseSequenceCount = ", TipPickupReverseSequenceCount);
			FormatTrace(source, action, TraceStatus::progress, "TipPickupChannelVariable = ", TipPickupChannelVariable);

			// tip eject settings 
			FormatTrace(source, action, TraceStatus::progress, "TipEjectUseDefaultWaste = ", TipEjectUseDefaultWaste);
			FormatTrace(source, action, TraceStatus::progress, "TipEjectWasteDestination.name = ", TipEjectWasteDestination.GetName());
			FormatTrace(source, action, TraceStatus::progress, "TipEjectWasteDestination.current = ", TipEjectWasteDestination.GetCurrentPosition());
			FormatTrace(source, action, TraceStatus::progress, "TipEjectWasteDestination.count = ", TipEjectWasteDestination.GetCount());
			FormatTrace(source, action, TraceStatus::progress, "TipEjectWasteDestination.total = ", TipEjectWasteDestination.GetTotal());
			FormatTrace(source, action, TraceStatus::progress, "TipEjectWasteDestination.maxPos = ", TipEjectWasteDestination.GetMax());
			FormatTrace(source, action, TraceStatus::progress, "TipEjectChannelUse = ", TipEjectChannelUse);
			FormatTrace(source, action, TraceStatus::progress, "TipEjectSequenceCounting = ", TipEjectSequenceCounting);
			FormatTrace(source, action, TraceStatus::progress, "TipEjectChannelVariable = ", TipEjectChannelVariable);

			// aspirate settings 
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequence.name = ", AspirateSequence.GetName());
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequence.current = ", AspirateSequence.GetCurrentPosition());
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequence.count = ", AspirateSequence.GetCount());
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequence.total = ", AspirateSequence.GetTotal());
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequence.maxPos = ", AspirateSequence.GetMax());
			FormatTrace(source, action, TraceStatus::progress, "AspirateSequenceCounting = ", AspirateSequenceCounting);
			FormatTrace(source, action, TraceStatus::progress, "AspirateChannelUse = ", AspirateChannelUse);
			FormatTrace(source, action, TraceStatus::progress, "AspirateMode = ", AspirateMode);
			FormatTrace(source, action, TraceStatus::progress, "AspirateCLLDSensitivity = ", AspirateCLLDSensitivity);
			FormatTrace(source, action, TraceStatus::progress, "AspirateFluidHeight = ", AspirateFluidHeight);
			FormatTrace(source, action, TraceStatus::progress, "AspirateSubmergeDepth = ", AspirateSubmergeDepth);
			size = AspirateVolumes.GetSize();
			for (index = 0; index < size; index++)
				FormatTrace(source, action, TraceStatus::progress,
								"AspirateVolumes[", index, "] = ", AspirateVolumes.GetAt(index));
			FormatTrace(source, action, TraceStatus::progress, "AspirateChannelVariable = ", AspirateChannelVariable);
			FormatTrace(source, action, TraceStatus::progress, "AspirateMaxHeightDiff = ", AspirateMaxHeightDiff);
			FormatTrace(source, action, TraceStatus::progress, "AspiratePLLDSensitivity = ", AspiratePLLDSensitivity);
			FormatTrace(source, action, TraceStatus::progress, "AspirateLiquidFollowing = ", AspirateLiquidFollowing);
			FormatTrace(source, action, TraceStatus::progress, "AspiratePrerinsingMixCycles = ", AspiratePrerinsingMixCycles);
			FormatTrace(source, action, TraceStatus::progress, "AspiratePrerinsingMixPosition = ", AspiratePrerinsingMixPosition);
			FormatTrace(source, action, TraceStatus::progress, "AspiratePrerinsingMixVolume = ", AspiratePrerinsingMixVolume);
			FormatTrace(source, action, TraceStatus::progress, "AspirateUserDefinedLiquidClass = ", AspirateUserDefinedLiquidClass);
			size = AspirateUserDefinedLiquidClasses.GetSize();
			for (index = 0; index < size; index++)
				FormatTrace(source, action, TraceStatus::progress,
								"AspirateUserDefinedLiquidClasses[", index, "] = ", AspirateUserDefinedLiquidClasses .GetAt(index));

			// dispense settings 
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequence.name = ", DispenseSequence.GetName());
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequence.current = ", DispenseSequence.GetCurrentPosition());
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequence.count = ", DispenseSequence.GetCount());
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequence.total = ", DispenseSequence.GetTotal());
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequence.maxPos = ", DispenseSequence.GetMax());
			FormatTrace(source, action, TraceStatus::progress, "DispenseSubmergeDepth = ", DispenseSubmergeDepth);
			size = DispenseVolumes.GetSize();
			for (index = 0; index < size; index++)
				FormatTrace(source, action, TraceStatus::progress,
								"volume[", index, "] = ", DispenseVolumes.GetAt(index));
			FormatTrace(source, action, TraceStatus::progress, "DispenseChannelVariable = ", DispenseChannelVariable);
			FormatTrace(source, action, TraceStatus::progress, "DispenseRestVolumeDestination = ", DispenseRestVolumeDestination);
			FormatTrace(source, action, TraceStatus::progress, "DispenseRestVolumeFluidHeight = ", DispenseRestVolumeFluidHeight);
			FormatTrace(source, action, TraceStatus::progress, "DispenseChannelUse = ", DispenseChannelUse);
			FormatTrace(source, action, TraceStatus::progress, "DispenseCLLDSensitivity = ", DispenseCLLDSensitivity);
			FormatTrace(source, action, TraceStatus::progress, "DispenseSequenceCounting = ", DispenseSequenceCounting);
			FormatTrace(source, action, TraceStatus::progress, "DispenseFluidHeight = ", DispenseFluidHeight);
			FormatTrace(source, action, TraceStatus::progress, "DispenseMode = ", DispenseMode);
			FormatTrace(source, action, TraceStatus::progress, "DispenseLiquidFollowing = ", DispenseLiquidFollowing);
			FormatTrace(source, action, TraceStatus::progress, "DispensePrerinsingMixCycles = ", DispensePrerinsingMixCycles);
			FormatTrace(source, action, TraceStatus::progress, "DispensePrerinsingMixPosition = ", DispensePrerinsingMixPosition);
			FormatTrace(source, action, TraceStatus::progress, "DispensePrerinsingMixVolume = ", DispensePrerinsingMixVolume);
			FormatTrace(source, action, TraceStatus::progress, "DispenseUserDefinedLiquidClass = ", DispenseUserDefinedLiquidClass);
			size = DispenseUserDefinedLiquidClasses.GetSize();
			for (index = 0; index < size; index++)
				FormatTrace(source, action, TraceStatus::progress,
								"DispenseUserDefinedLiquidClasses[", index, "] = ", DispenseUserDefinedLiquidClasses.GetAt(index));
			#endif
		}

		static function DumpSequence(sequence& sequenceObj, variable indexesOnly)
		{
			#ifdef _DEBUG
			variable currentPos(0);										// current position
			variable currentPosBak(0);									// backup of inital current position
			variable countPosBak(0);									// backup of inital count position
			variable source;
			variable action;
			source = "DEBUG";
			action = GetFunctionName();

			// dump indexes
			FormatTrace(source, action, TraceStatus::progress, "name = ", sequenceObj.GetName());
			FormatTrace(source, action, TraceStatus::progress, "current = ", sequenceObj.GetCurrentPosition());
			FormatTrace(source, action, TraceStatus::progress, "count = ", sequenceObj.GetCount());
			FormatTrace(source, action, TraceStatus::progress, "total = ", sequenceObj.GetTotal());
			FormatTrace(source, action, TraceStatus::progress, "maxPos = ", sequenceObj.GetMax());
			FormatTrace(source, action, TraceStatus::progress, "usedPos = ", sequenceObj.GetUsedPositions());

			// dump positions
			if (!indexesOnly)
			{

				// backup current position
				currentPosBak = sequenceObj.GetCurrentPosition();

				// backup count position
				countPosBak = sequenceObj.GetCount();

				sequenceObj.SetCount(sequenceObj.GetTotal());
				for (currentPos = sequenceObj.SetCurrentPosition(1); currentPos != 0; currentPos = sequenceObj.Increment(1))
					 FormatTrace(source, action, TraceStatus::progress, 
									"labwareId = ", sequenceObj.GetLabwareId(), ", positionId = ", sequenceObj.GetPositionId());

				// restore count position
				sequenceObj.SetCount(countPosBak);

				// restore current position
				sequenceObj.SetCurrentPosition(currentPosBak);
			}

			#endif
		}
	}

	function ExecuteWorklist(
		device& ML_STAR, 
		sequence& tipPickupSequence,
		variable& channelPattern,
		variable& barcodeFileName,
		variable& worklistFileName,
		variable& liquidClassName)
	{
		#ifdef _DEBUG
		file debugWorklistFile;								// handle to debug worklist file
		variable debugWorklistFileName;					// name of debug worklist file
		variable channels[];									// column variables in debug worklist file
		#endif
		#ifdef _XLS_WORKLIST
		variable xlsWorklistFilePathName;				// name of worklist file if exported into an excel file
		variable xlsWorklistFileDeleteName;				// name to delete the intermediate worklist file if exported into an excel file (decorated with string delimiters)
		#endif

		file worklistFile;									// handle to worklist file
		file formatedBarcodeFile;							// handle to formated barcode file
		variable formatedBarcodeFileStatus(0);			// status of formated barcode file (0 = closed, 1 = opened)
		variable formatedBarcodeFileName;				// name of formated barcode file
		variable worklistTableName("");					// variable to build table name of worklist file
		variable worklistFilePathName("");				// path and name to current worklist file (txt,csv,tab,asc,~.csv)
		variable worklistFilePathName2("");				// path and name to original worklist file (e.g. gwl)
		variable worklistFileCopyName("");				// path and name of copy of worklist file (~.csv)
		variable worklistFileExtension("");				// extension of worklist file
		variable delimitedWorklistFileCopyName("");	// delimited path and name of copy of worklist file
		variable barcodeFilePathName("");				// path and name of barcode file
		variable row;											// a row number in the worklist file
		variable size;											// an array size
		variable index;										// a loop counter
		variable length;										// string length
		variable traceSource("");							// source for formated trace
		variable traceAction("");							// action for formated trace
		variable iterator[];									// iterator used to iterate over worklist file
		variable eof(hslFalse);								// indicates end of worklist file
		variable channel;										// a channel number
		variable numberOfChannels;							// number of channels
		variable sqlStatement;								// sql statement

		variable id(0);										// colunm variable (record id)
		variable specifier("");								// colunm variable (labware specifier, C = carrier, P = position)
		variable position1(0);								// colunm variable (position)
		variable barcode("");								// colunm variable (barcode)
		variable timestamp("");								// colunm variable (timestamp)
		variable labwareId("");								// colunm variable (labware id)

		variable stepType("");								// colunm variable (step type, {A,D,W,F,B})
		variable rackLabel("");								// colunm variable (labware id)
		variable rackId("");									// colunm variable (carrier barcode)
		variable rackName("");								// colunm variable (base name of default labware id)
		variable position2(0);								// colunm variable (position in current labware, from top left to bottom right)
		variable tubeId("");									// colunm variable (labware barcode)
		variable volume(0);									// colunm variable (volume)
		variable liquidClass("");							// colunm variable (liquid class)

		variable rc[];											// step return 
		variable noBarcode("");								// place to load the string 'No barcode' from the string table
		variable noLabware("");								// place to load the string 'No labware' from the string table
		string stepTypePattern("");						// step type per channel, e.g. "AAAAAAAA" or "W W F F "
		variable errorDesc;									// place to hold formated error description

		// activate error handler
		onerror goto Unexpected;

		// initialize HSLML_STAR library
		InitHSLML_STARLibraryCore();

		// load strings from the string table
		noBarcode = StringTable::Load(IDS::noBarcode);
		noLabware = StringTable::Load(IDS::noLabware);

		// trace start of worklist execution
		traceSource = StringTable::Load(IDS::traceSource);
		traceAction = StringTable::Load(IDS::traceActionExecuteWorklist);
		FormatTrace(traceSource, traceAction, TraceStatus::start);

		// search the worklist file
		worklistFilePathName = SearchPath(worklistFileName);
		if ("" == worklistFilePathName)
			worklistFilePathName = SearchPath(GetLogFilesPath() + "\\" + worklistFileName);
		worklistFilePathName2 = worklistFilePathName;

		// search the barcode file
		barcodeFilePathName = SearchPath(barcodeFileName);
		if ("" == barcodeFilePathName)
			barcodeFilePathName = SearchPath(GetLogFilesPath() + "\\" + barcodeFileName);

		// dump input params
		#ifdef _DEBUG
		FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "channelPattern = ", channelPattern);
		FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "worklistFileName = ", worklistFileName);
		FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "worklistFilePathName = ", worklistFilePathName);
		FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "barcodeFileName = ", barcodeFileName);
		FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "barcodeFilePathName = ", barcodeFilePathName);
		FormatTrace("DEBUG", GetFunctionName(), TraceStatus::progress, "liquidClassName = ", liquidClassName);
		#endif

		// check input parameters to be valid
		length = StrGetLength(channelPattern);
		if (!Util::IsString(channelPattern))
			Error::Raise(IDE::invalidChannelPattern, GetFileName(), GetFunctionName(), GetLineNumber());
		if (length < 1 || Global::maxNumberOfChannels < length)
			Error::Raise(IDE::invalidChannelPattern, GetFileName(), GetFunctionName(), GetLineNumber());
		if (!Util::IsString(worklistFileName))
			Error::Raise(IDE::invalidFileName, GetFileName(), GetFunctionName(), GetLineNumber());
		if ("" == worklistFileName)
			Error::Raise(IDE::invalidFileName, GetFileName(), GetFunctionName(), GetLineNumber());
		if ("" == worklistFilePathName)
		{
			errorDesc = StringTable::Load(IDE::fileNotFound);
			StrReplace(errorDesc, "%s", worklistFileName);
			Error::RaiseEx(IDE::fileNotFound, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
		}
		if (!Util::IsString(barcodeFileName))
			Error::Raise(IDE::invalidFileName, GetFileName(), GetFunctionName(), GetLineNumber());
		if ("" == barcodeFilePathName && "" != barcodeFileName)
		{
			errorDesc = StringTable::Load(IDE::fileNotFound);
			StrReplace(errorDesc, "%s", barcodeFileName);
			Error::RaiseEx(IDE::fileNotFound, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
		}
		if (!Util::IsString(liquidClassName))
			Error::Raise(IDE::invalidLiquidClass, GetFileName(), GetFunctionName(), GetLineNumber());

		// format barcode file
		if ("" != barcodeFileName)
		{
			variable formatedBarcodeFileDeleteName;			// name used to delete the formated barcode file (decorated with string delimiters)
			index = StrReverseFind(barcodeFileName, ".");
			if (0 <= index)
				formatedBarcodeFileName = StrLeft(barcodeFileName, index) + StringConstants::barcodeFileExt2;
			else
				formatedBarcodeFileName = barcodeFileName + StringConstants::barcodeFileExt2;
			formatedBarcodeFileDeleteName = formatedBarcodeFileName;
			if (StrMid(formatedBarcodeFileDeleteName, 0, 1) != "\"")
				 formatedBarcodeFileDeleteName = "\"" + formatedBarcodeFileDeleteName;
			if (StrMid(formatedBarcodeFileDeleteName, StrGetLength(formatedBarcodeFileDeleteName) - 1, 1) != "\"")
				 formatedBarcodeFileDeleteName = formatedBarcodeFileDeleteName + "\"";
			Shell(CmdInterpreter::cmdPrompt + " /c del "+ formatedBarcodeFileDeleteName, hslHide, hslSynchronous);
			formatedBarcodeFileName = formatedBarcodeFileName + " " + StringConstants::barcodeFileTable;
			FormatBarcodeFile(ML_STAR, barcodeFileName, formatedBarcodeFileName);

			// open formated barcode file
			formatedBarcodeFile.AddField("Id", id, hslInteger);
			formatedBarcodeFile.AddField("Specifier", specifier, hslString);
			formatedBarcodeFile.AddField("Position", position1, hslString);
			formatedBarcodeFile.AddField("Barcode", barcode, hslString);
			formatedBarcodeFile.AddField("Timestamp", timestamp, hslString);
			formatedBarcodeFile.AddField("LabwareId", labwareId, hslString);
			if (!formatedBarcodeFile.Open(formatedBarcodeFileName, hslRead))
			{
				errorDesc = StringTable::Load(IDE::fileOpenFailed);
				StrReplace(errorDesc, "%s", formatedBarcodeFileName);
				Error::RaiseEx(IDE::fileOpenFailed, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
			}

			// state that formated barcode file has been opened
			formatedBarcodeFileStatus = 1;
		}

		// check the extension of the worklist file to be supported 
		// by the Microsoft Jet 4.0 Text Engine
		length = StrGetLength(worklistFilePathName);
		index = StrReverseFind(worklistFilePathName, ".");
		if (0 <= index)
			worklistFileExtension = StrMid(worklistFilePathName, index + 1, length);
		if (StrFind(StringConstants::textFileExtensions, worklistFileExtension) <= 0)
		{
			// extension of worklist file not supported,
			// copy worklist file to temporary file
			index = StrReverseFind(worklistFilePathName, ".");
			if (0 <= index)
				worklistFileCopyName = StrLeft(worklistFilePathName, index) + StringConstants::worklistFileCopyExt;
			else
				worklistFileCopyName = worklistFilePathName + StringConstants::worklistFileCopyExt;
			delimitedWorklistFileCopyName = worklistFileCopyName;
			if (StrMid(delimitedWorklistFileCopyName, 0, 1) != "\"")
				 delimitedWorklistFileCopyName = "\"" + delimitedWorklistFileCopyName;
			if (StrMid(delimitedWorklistFileCopyName, StrGetLength(delimitedWorklistFileCopyName) - 1, 1) != "\"")
				 delimitedWorklistFileCopyName = delimitedWorklistFileCopyName + "\"";
			Shell(CmdInterpreter::cmdPrompt + " /c del " + delimitedWorklistFileCopyName, hslHide, hslSynchronous);
			Shell(CmdInterpreter::cmdPrompt + " /c copy \"" + worklistFilePathName + "\" " + delimitedWorklistFileCopyName, hslHide, hslSynchronous);
			worklistFilePathName = worklistFileCopyName;
		}

		// setup worklist table name (used to execute an sql statement)
		worklistTableName = worklistFilePathName;
		index = StrReverseFind(worklistFilePathName, "\\");
		if (0 <= index)
			worklistTableName = StrMid(worklistFilePathName, index + 1, StrGetLength(worklistFilePathName));
		StrReplace(worklistTableName, ".","#");
		StrReplace(worklistTableName, ";","_");
		StrReplace(worklistTableName, ":","_");
		StrReplace(worklistTableName, "*","_");

		// format worklist file
		#ifdef _XLS_WORKLIST
		index = StrReverseFind(worklistFilePathName, ".");
		if (0 <= index)
			xlsWorklistFilePathName = StrLeft(worklistFilePathName, index) + ".xls";
		else
			xlsWorklistFilePathName = worklistFilePathName + ".xls";
		xlsWorklistFileDeleteName = xlsWorklistFilePathName;
		if (StrMid(xlsWorklistFileDeleteName, 0, 1) != "\"")
			 xlsWorklistFileDeleteName = "\"" + xlsWorklistFileDeleteName;
		if (StrMid(xlsWorklistFileDeleteName, StrGetLength(xlsWorklistFileDeleteName) - 1, 1) != "\"")
			 xlsWorklistFileDeleteName = xlsWorklistFileDeleteName + "\"";
		Shell(CmdInterpreter::cmdPrompt + " /c del " + xlsWorklistFileDeleteName, hslHide, hslSynchronous);
		sqlStatement = "SELECT * INTO [Worklist] IN \"" + xlsWorklistFilePathName + "\" \"Excel 8.0;\" FROM [" + worklistTableName + "]";
		#endif

		// setup sql statement to skip over comments
		#ifndef _XLS_WORKLIST
		sqlStatement = "SELECT * FROM [" + worklistTableName + "] WHERE NOT F1 = 'C'";
		#endif

		// open worklist file
		worklistFile.SetDelimiter(StringConstants::worklistDelimiter);
		worklistFile.AddField(1	, stepType, hslString);
		worklistFile.AddField(2, rackLabel, hslString);
		worklistFile.AddField(3, rackId, hslString);
		worklistFile.AddField(4, rackName, hslString);
		worklistFile.AddField(5, position2, hslString);
		worklistFile.AddField(6, tubeId, hslString);
		worklistFile.AddField(7, volume, hslFloat);
		worklistFile.AddField(8, liquidClass, hslString);
		if (!worklistFile.Open(worklistFilePathName, hslAppend, sqlStatement))
		{
			errorDesc = StringTable::Load(IDE::fileOpenFailed);
			StrReplace(errorDesc, "%s", worklistFilePathName);
			Error::RaiseEx(IDE::fileOpenFailed, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
		}
		#ifdef _XLS_WORKLIST
		worklistFile.Close();

		// setup sql statement to skip over comments
		sqlStatement = "SELECT * FROM [Worklist] WHERE NOT F1 = 'C'";

		// open worklist file
		if (!worklistFile.Open(xlsWorklistFilePathName + " Worklist", hslAppend, sqlStatement))
		{
			errorDesc = StringTable::Load(IDE::fileOpenFailed);
			StrReplace(errorDesc, "%s", xlsWorklistFilePathName);
			Error::RaiseEx(IDE::fileOpenFailed, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
		}
		#endif

		// set number of channels
		numberOfChannels = StrGetLength(channelPattern);

		#ifdef _DEBUG
		{
		variable debugWorklistFileDeleteName;			// name used to delete the formated worklist file (has string delimiters)
		// open file for formated worklist 
		index = StrReverseFind(worklistFilePathName, ".");
		if (0 <= index)
			debugWorklistFileName = StrLeft(worklistFilePathName, index) + StringConstants::worklistFileExt;
		else
			debugWorklistFileName = worklistFilePathName + StringConstants::worklistFileExt;
		debugWorklistFileDeleteName = debugWorklistFileName;
		if (StrMid(debugWorklistFileDeleteName, 0, 1) != "\"")
			 debugWorklistFileDeleteName = "\"" + debugWorklistFileDeleteName;
		if (StrMid(debugWorklistFileDeleteName, StrGetLength(debugWorklistFileDeleteName) - 1, 1) != "\"")
			 debugWorklistFileDeleteName = debugWorklistFileDeleteName + "\"";
		Shell(CmdInterpreter::cmdPrompt + " /c del " + debugWorklistFileDeleteName, hslHide, hslSynchronous);
		debugWorklistFileName = debugWorklistFileName + " " + StringConstants::worklistFileTable;
		channels.SetSize(numberOfChannels);
		for (channel = 1; channel <= numberOfChannels; channel++)
			debugWorklistFile.AddField("Channel_" + IStr(channel), channels.ElementAt(channel - 1), hslString);
		if (!debugWorklistFile.Open(debugWorklistFileName, hslAppend))
		{
			errorDesc = StringTable::Load(IDE::fileOpenFailed);
			StrReplace(errorDesc, "%s", debugWorklistFileName);
			Error::RaiseEx(IDE::fileOpenFailed, errorDesc, GetFileName(), GetFunctionName(), GetLineNumber());
		}
		}
		#endif

		// reset pipetting state and sequences which have not been explicitly set by the user
		PCB::ResetPipettingStateAndSequences(hslFalse);

		// set default waste
		PCB::SetDefaultWaste(ML_STAR, channelPattern);

		// set tip type
		PCB::SetTipType(ML_STAR, tipPickupSequence);

		// dump pipetting settings
		#ifdef _DEBUG
		PCB::Dump();
		#endif

		// set current tip volume
		TipVolume::current.SetSize(0);
		TipVolume::current.SetSize(numberOfChannels);

		// initialize pipetting device
		PCB::InitializeChannelVariable = channelPattern;
		PCB::InitPipettingDevice(ML_STAR);

		// initialize iterator
		eof = Iterator::SetToFirst(worklistFile, channelPattern, iterator, 1);
		#ifdef _DEBUG
		Iterator::DumpIterator(iterator);
		#endif

		// iterate over worklist file
		while (!eof)
		{
			// reset step type pattern
			stepTypePattern = "";

			// reset pipetting sequences
			SeqRemoveAll(PCB::AspirateSequence);
			SeqRemoveAll(PCB::DispenseSequence);

			// reset pipetting volumes
			PCB::AspirateVolumes.SetSize(0);
			PCB::DispenseVolumes.SetSize(0);

			// reset liquid class names
			PCB::AspirateUserDefinedLiquidClasses.SetSize(0);
			PCB::DispenseUserDefinedLiquidClasses.SetSize(0);

			// reset all pipetting channel variables but the TipPickupChannelVariable
			PCB::TipEjectChannelVariable = "";
			PCB::AspirateChannelVariable = "";
			PCB::DispenseChannelVariable = "";

			// get pipetting params for each channel
			for (channel = 1; channel <= numberOfChannels; channel++)
			{
				// reset column variables
				stepType = rackLabel = rackId = rackName = position2 = tubeId = liquidClass = "";
				volume = 0;

				// read the pipetting params for this channel
				row = iterator.GetAt(channel);
				if (0 < row)
				{
					// set file pointer to row containing the params for this channel
					if (0 == worklistFile.Seek(row - 1, hslFirst))
						Error::Raise(IDE::unexpectedEndOfFile, worklistFilePathName2, "", IStr(row));
					
					// the channel is active,
					// read the pipetting params for this channel
					worklistFile.ReadRecord();

					if ("A" == stepType || "D" == stepType)
					{

						// it's an Aspirate or a Dispense step
						// check if we got a rack label
						if (!Util::IsString(rackLabel))
						{
							// we got no rack label,
							// check if we got a rack barcode
							if (!Util::IsString(rackId))
							{
								// we got no rack barcode,
								// check if we got a tube barcode
								if (!Util::IsString(tubeId))
								{
									// we got no tube barcode,
									// so what ????
									Error::Raise(IDE::expectedLabwareIdOrBarcode, worklistFilePathName2, "", IStr(row));
								}
								else
								{
									// we got a tube barcode,
									// search associated labware id in the formated barcode file
									if (1 == formatedBarcodeFileStatus && 
										 0 < formatedBarcodeFile.Seek(0, hslFirst, "Barcode = '" + tubeId + "'"))
									{
										// found the barcode in the formated barcode file
										formatedBarcodeFile.ReadRecord();
										if (noLabware != labwareId)
										{
											// found an associated labware id in the formated barcode file
											rackLabel = labwareId;

											// take the position from the barcode file
											position2 = position1;
										}
										else
										{
											// found no associated labware id in the formated barcode file,
											// raise an error
											variable errorDesc;
											errorDesc = StringTable::Load(IDE::noLabware);
											StrReplace(errorDesc, "%s", tubeId);
											Error::RaiseEx(IDE::noLabware, errorDesc, worklistFilePathName2, "", IStr(row));
										}
									}
									else
									{
										// didn't find the barcode in the formated barcode file,
										// raise an error
										variable errorDesc;
										errorDesc = StringTable::Load(IDE::noBarcode);
										StrReplace(errorDesc, "%s", tubeId);
										Error::RaiseEx(IDE::noBarcode, errorDesc, worklistFilePathName2, "", IStr(row));
									}
								}
							}
							else
							{
								// we got a rack barcode,
								// search associated labware id in the formated barcode file
								if (1 == formatedBarcodeFileStatus && 
									 0 < formatedBarcodeFile.Seek(0, hslFirst, "Barcode = '" + rackId + "'"))
								{
									// found the barcode in the formated barcode file
									formatedBarcodeFile.ReadRecord();
									if (noLabware != labwareId)
									{
										// found an associated labware id in the formated barcode file
										rackLabel = labwareId;

										// take the position from the worklist file (nothing to do),
										// check if we got a position
										if (!Util::IsString(position2))
										{
											// we got no position,
											// raise an error
											variable errorDesc;
											errorDesc = StringTable::Load(IDE::noPosition);
											StrReplace(errorDesc, "%s", rackLabel);
											Error::RaiseEx(IDE::noPosition, errorDesc, worklistFilePathName2, "", IStr(row));
										}
									}
									else
									{
										// found no associated labware id in the formated barcode file,
										// raise an error
										variable errorDesc;
										errorDesc = StringTable::Load(IDE::noLabware);
										StrReplace(errorDesc, "%s", rackId);
										Error::RaiseEx(IDE::noLabware, errorDesc, worklistFilePathName2, "", IStr(row));
									}
								}
								else
								{
									// didn't find the barcode in the formated barcode file,
									// raise an error
									variable errorDesc;
									errorDesc = StringTable::Load(IDE::noBarcode);
									StrReplace(errorDesc, "%s", rackId);
									Error::RaiseEx(IDE::noBarcode, errorDesc, worklistFilePathName2, "", IStr(row));
								}
							}
						}
						else
						{
							// we got a rack label,
							// check if we got a position
							if (!Util::IsString(position2))
							{
								// we got no position,
								// raise an error
								variable errorDesc;
								errorDesc = StringTable::Load(IDE::noPosition);
								StrReplace(errorDesc, "%s", rackLabel);
								Error::RaiseEx(IDE::noPosition, errorDesc, worklistFilePathName2, "", IStr(row));
							}
						}
						#ifdef _DEBUG
						Assert("" != rackLabel && "" != position2, GetFunctionName());
						#endif

						// check the volume to be valid 
						if (!Util::IsNumber(volume))
							Error::Raise(IDE::invalidVolume, worklistFilePathName2, "", IStr(row));
						if (Util::IsNegative(volume))
							Error::Raise(IDE::invalidVolume, worklistFilePathName2, "", IStr(row));

						// add position to pipetting sequence
						if ("A" == stepType)
						{
							// it's an Aspirate step,
							// update sequence, channel variable and volume
							PCB::AspirateVolumes.AddAsLast(volume);
							PCB::AspirateSequence.Add(rackLabel, position2);
							PCB::AspirateChannelVariable = PCB::AspirateChannelVariable + "1";
							PCB::DispenseVolumes.AddAsLast(0);
							PCB::DispenseChannelVariable = PCB::DispenseChannelVariable + "0";

							// toggle the bit for this channel in the TipPickupChannelVariable,
							// the TipPickupChannelVariable grows automatically if necessary
							PCB::ToggleChannel(PCB::TipPickupChannelVariable, channel);

							// set liquid class
							if (Util::IsString(liquidClass))
							{
								PCB::AspirateUserDefinedLiquidClasses.AddAsLast(liquidClass);
							}
							else
							{
								if ("" == liquidClassName)
									Error::Raise(IDE::missingLiquidClass, worklistFilePathName2, "", IStr(row));
								PCB::AspirateUserDefinedLiquidClasses.AddAsLast(liquidClassName);
							}

							// check for multiple liquid classes
							size = PCB::AspirateUserDefinedLiquidClasses.GetSize();
							if (1 < size)
							{
								if (PCB::AspirateUserDefinedLiquidClasses.ElementAt(size - 2) != 
									 PCB::AspirateUserDefinedLiquidClasses.ElementAt(size - 1))
									Error::Raise(IDE::multipleLiquidClasses, worklistFilePathName2, "", IStr(row));
							}
						}
						if ("D" == stepType)
						{
							// it's a Dispense step,
							// update sequence, channel variable and volume
							PCB::DispenseVolumes.AddAsLast(volume);
							PCB::DispenseSequence.Add(rackLabel, position2);
							PCB::DispenseChannelVariable = PCB::DispenseChannelVariable + "1";
							PCB::AspirateVolumes.AddAsLast(0);
							PCB::AspirateChannelVariable = PCB::AspirateChannelVariable + "0";

							// toggle the bit for this channel in the TipPickupChannelVariable,
							// the TipPickupChannelVariable grows automatically if necessary
							PCB::ToggleChannel(PCB::TipPickupChannelVariable, channel);

							// set liquid class
							if (Util::IsString(liquidClass))
							{
								PCB::DispenseUserDefinedLiquidClasses.AddAsLast(liquidClass);
							}
							else
							{
								if ("" == liquidClassName)
									Error::Raise(IDE::missingLiquidClass, worklistFilePathName2, "", IStr(row));
								PCB::DispenseUserDefinedLiquidClasses.AddAsLast(liquidClassName);
							}

							// check for multiple liquid classes
							size = PCB::DispenseUserDefinedLiquidClasses.GetSize();
							if (1 < size)
							{
								if (PCB::DispenseUserDefinedLiquidClasses.ElementAt(size - 2) != 
									 PCB::DispenseUserDefinedLiquidClasses.ElementAt(size - 1))
									Error::Raise(IDE::multipleLiquidClasses, worklistFilePathName2, "", IStr(row));
							}
						}

						// update step type pattern
						stepTypePattern = stepTypePattern + stepType;
					}
					else
					{
						// it's neither an Aspirate nor a Dispense step,
						// so it can only be a Wash or Flush step
						if ("W" != stepType && "F" != stepType)
							Error::Raise(IDE::invalidStepType, worklistFilePathName2, "", IStr(row));

						if ("W" == stepType)
						{
							// it's a Wash step,
							// update channel variable and volume
							PCB::DispenseVolumes.AddAsLast(0);
							PCB::TipEjectChannelVariable = PCB::TipEjectChannelVariable + "1";
							PCB::DispenseChannelVariable = PCB::DispenseChannelVariable + "0";
						}
						if ("F" == stepType)
						{
							// it's a Flush step,
							// update sequence, channel variable and volume
							variable currentPosBak;
							currentPosBak = PCB::TipEjectWasteDestination.GetCurrentPosition();
							PCB::TipEjectWasteDestination.SetCurrentPosition(channel);
							PCB::DispenseVolumes.AddAsLast(TipVolume::current.GetAt(channel - 1));
							PCB::DispenseSequence.Add(PCB::TipEjectWasteDestination.GetLabwareId(), 
															  PCB::TipEjectWasteDestination.GetPositionId());
							PCB::TipEjectWasteDestination.SetCurrentPosition(currentPosBak);
							PCB::TipEjectChannelVariable = PCB::TipEjectChannelVariable + "0";
							PCB::DispenseChannelVariable = PCB::DispenseChannelVariable + "1";

							// set liquid class
							if (Util::IsString(liquidClass))
							{
								PCB::DispenseUserDefinedLiquidClasses.AddAsLast(liquidClass);
							}
							else
							{
								if ("" == liquidClassName)
									Error::Raise(IDE::missingLiquidClass, worklistFilePathName2, "", IStr(row));
								PCB::DispenseUserDefinedLiquidClasses.AddAsLast(liquidClassName);
							}

							// check for multiple liquid classes
							size = PCB::DispenseUserDefinedLiquidClasses.GetSize();
							if (1 < size)
							{
								if (PCB::DispenseUserDefinedLiquidClasses.ElementAt(size - 2) != 
									 PCB::DispenseUserDefinedLiquidClasses.ElementAt(size - 1))
									Error::Raise(IDE::multipleLiquidClasses, worklistFilePathName2, "", IStr(row));
							}
						}

						// update step type pattern
						stepTypePattern = stepTypePattern + stepType;
					}
				}
				else
				{
					// the channel isn't active,
					// update channel variables and volumes
					PCB::AspirateVolumes.AddAsLast(0);
					PCB::DispenseVolumes.AddAsLast(0);
					PCB::AspirateChannelVariable = PCB::AspirateChannelVariable + "0";
					PCB::DispenseChannelVariable = PCB::DispenseChannelVariable + "0";
					PCB::TipEjectChannelVariable = PCB::TipEjectChannelVariable + "0";
					// clear the bit for this channel in the TipPickupChannelVariable,
					// the TipPickupChannelVariable grows automatically if necessary
					PCB::ClearChannel(PCB::TipPickupChannelVariable, channel);

					// update step type pattern
					stepTypePattern = stepTypePattern + " ";
				}

				#ifdef _DEBUG
				if ("" != stepType)
					channels.SetAt(channel - 1, stepType + "(" + IStr(row) + ")");
				else
					channels.SetAt(channel - 1, stepType);
				#endif
			}
			#ifdef _DEBUG
			debugWorklistFile.WriteRecord();
			#endif

			// initialize sequence properties
			PCB::AspirateSequence.SetCount(PCB::AspirateSequence.GetTotal());
			PCB::AspirateSequence.SetCurrentPosition(1);
			PCB::AspirateSequence.SetMax(PCB::AspirateSequence.GetCount());
			PCB::DispenseSequence.SetCount(PCB::DispenseSequence.GetTotal());
			PCB::DispenseSequence.SetCurrentPosition(1);
			PCB::DispenseSequence.SetMax(PCB::DispenseSequence.GetCount());

			// switch over step type
			if ("" == stepTypePattern.SpanExcluding("WF"))
			{
				// it's a Wash or Flush step

				// dump current pipetting sequences
				#ifdef _DEBUG
				//PCB::DumpSequence(PCB::DispenseSequence, hslTrue);
				#endif

				// track volume 
				PCB::TrackVolume(worklistFilePathName2, iterator, stepTypePattern);

				// transfer liquid
				StepReturn::Empty(rc);
				rc = PCB::FlushLiquid(ML_STAR, tipPickupSequence);

				// eject pipetting tips 
				StepReturn::Empty(rc);
				rc = PCB::EjectPipettingTips(ML_STAR);
				PCB::TipPickupChannelVariable = PCB::DispenseChannelVariable;
			}
			else
			{
				// it's an Aspirate and / or Dispense step

				// dump current pipetting sequences
				#ifdef _DEBUG
				//PCB::DumpSequence(tipPickupSequence, hslTrue);
				//PCB::DumpSequence(PCB::AspirateSequence, hslTrue);
				//PCB::DumpSequence(PCB::DispenseSequence, hslTrue);
				#endif

				// track volume 
				PCB::TrackVolume(worklistFilePathName2, iterator, stepTypePattern);

				// pickup pipetting tips (if necessary)
				StepReturn::Empty(rc);
				rc = PCB::PickupPipettingTips(ML_STAR, tipPickupSequence);

				// transfer liquid
				StepReturn::Empty(rc);
				rc = PCB::TransferLiquid(ML_STAR, tipPickupSequence);
			}

			// increment iterator
			eof = Iterator::SetToNext(worklistFile, channelPattern, iterator);
			#ifdef _DEBUG
			Iterator::DumpIterator(iterator);
			#endif
		}

		// delete any copy of the worklist file
		if ("" != delimitedWorklistFileCopyName)
		{
			worklistFile.Close();
			Shell(CmdInterpreter::cmdPrompt + " /c del " + delimitedWorklistFileCopyName, hslHide, hslSynchronous);
		}

		// trace completion of worklist execution
		FormatTrace(traceSource, traceAction, TraceStatus::complete);

		return(hslTrue);

		Unexpected:
		{
			// eject pipetting tips (if necessary)
			StepReturn::Empty(rc);
			if (PCB::TipPickupEnabled && !PCB::TipPickupNow)
			{
				PCB::TipEjectChannelVariable = channelPattern;
				rc = PCB::EjectPipettingTips(ML_STAR);
			}

			// delete any copy of the worklist file
			if ("" != delimitedWorklistFileCopyName)
			{
				worklistFile.Close();
				Shell(CmdInterpreter::cmdPrompt + " /c del " + delimitedWorklistFileCopyName, hslHide, hslSynchronous);
			}

			// trace completion with error of pipetting 
			FormatTrace(traceSource, traceAction, TraceStatus::completeWithError);

			// check if we should abort the method
			// Remark: a request to abort the method is signaled 
			// by raising the 'methodAborted ' error id
			if (err.GetId() == IDE::methodAborted)
				abort;

			// re-throw the error 
			Error::RaiseLast();
		}
	}

	namespace StepReturn
	{

		static function Empty(variable& rc[])
		{
			rc.SetSize(0);
		}

		static function IsEmpty(variable& rc[])
		{
			return(rc.GetSize() == 0);
		}

		static function Bind(variable& rc[])
		{
			variable data[];
			data = err.GetData();
			if (0 < data.GetSize())
				rc = data;
			else
				// re-throw error
				Error::RaiseLast();
		}

		static function Evaluate(
			device& ML_STAR,
			variable& rc[],
			variable& channelPattern)
		{
			variable status(hslFalse);				// evaluation status

			#ifdef _DEBUG
			Dump(rc);
			#endif

			if (2 < rc.GetSize())
			{
				variable stepReturn;					// step return (string)
				variable errorCode;					// error code (integer)

				// initialize field and block delimiters used in step returns from this device's configuration file
				StepReturn::SetBlockDelimiterEx(ML_STAR);
				StepReturn::SetFieldDelimiterEx(ML_STAR);

				stepReturn = rc.GetAt(2);

				errorCode = StepReturn::GetErrorCode(stepReturn);

				if (0 == errorCode)
				{
					// no error

					// set status
					status = hslTrue;
				}
				if (1 == errorCode)
				{
					// recoverable error

					variable stepType("");			// step type

					// switch over step types
					stepType = rc.GetAt(1);

					#ifdef _DEBUG
					Assert(StepType::aspirate == stepType || 
							 StepType::getLastLiquidLevel == stepType, GetFunctionName());
					#endif

					// aspirate step
					if (StepType::aspirate == stepType)
					{
						// aspirate error

						// evaluate aspirate recovery
						status = EvaluateAspirateRecovery(stepReturn, channelPattern);

						// set internal data
						SetData(stepReturn, channelPattern);

						// dump internal state of StepReturn
						#ifdef _DEBUG
						DumpData();
						#endif
					}

					// getLastLiquidLevel step
					if (StepType::getLastLiquidLevel == stepType)
					{
						// getLastLiquidLevel error
					}
				}
				if (2 == errorCode)
				{
					// unrecoverable error,
					// re-throw error
					Error::RaiseLast();
				}
			}
			return(status);
		}

		static function EvaluateEx(
			device& ML_STAR,
			variable& rc[],
			variable& channelPattern)
		{
			variable status(hslFalse);				// evaluation status

			#ifdef _DEBUG
			Dump(rc);
			#endif

			if (2 < rc.GetSize())
			{
				variable stepReturn;					// step return (string)
				variable errorCode;					// error code (integer)

				// initialize field and block delimiters used in step returns from this device's configuration file
				StepReturn::SetBlockDelimiterEx(ML_STAR);
				StepReturn::SetFieldDelimiterEx(ML_STAR);

				stepReturn = rc.GetAt(2);

				errorCode = StepReturn::GetErrorCode(stepReturn);

				if (0 == errorCode)
				{
					// no error

					// set status
					status = hslTrue;
					return(status);
				}
				if (1 == errorCode)
				{
					// recoverable error

					variable stepType("");			// step type

					// switch over step types
					stepType = rc.GetAt(1);

					if (StepType::initialize == stepType)
					{
						// set status
						if (ErrorHandling::continue == PCB::ErrorHandling)
						{
							// evaluate generic recovery
							EvaluateGenericRecovery(stepReturn);
							status = hslTrue;
						}
						else
							status = hslFalse;
						return(status);
					}
					if (StepType::tipPickup == stepType)
					{
						// set status
						if (ErrorHandling::continue == PCB::ErrorHandling)
						{
							// evaluate generic recovery
							EvaluateGenericRecovery(stepReturn);
							status = hslTrue;
						}
						else
							status = hslFalse;
						return(status);
					}
					if (StepType::tipEject == stepType)
					{
						// set status
						if (ErrorHandling::continue == PCB::ErrorHandling)
						{
							// evaluate generic recovery
							EvaluateGenericRecovery(stepReturn);
							status = hslTrue;
						}
						else
							status = hslFalse;
						return(status);
					}

					// aspirate step
					if (StepType::aspirate == stepType)
					{
						// set status
						if (ErrorHandling::continue == PCB::ErrorHandling)
						{
							// evaluate generic recovery
							EvaluateGenericRecovery(stepReturn);
							status = hslTrue;
						}
						else
							status = hslFalse;
						return(status);
					}

					// dispense step
					if (StepType::dispense == stepType)
					{
						// set status
						if (ErrorHandling::continue == PCB::ErrorHandling)
						{
							// evaluate generic recovery
							EvaluateGenericRecovery(stepReturn);
							status = hslTrue;
						}
						else
							status = hslFalse;
						return(status);
					}
					if (StepType::loadCarrier == stepType)
					{
						// set status
						if (ErrorHandling::continue == PCB::ErrorHandling)
						{
							// evaluate generic recovery
							EvaluateGenericRecovery(stepReturn);
							status = hslTrue;
						}
						else
							status = hslFalse;
						return(status);
					}
					if (StepType::unloadCarrier == stepType)
					{
						// set status
						if (ErrorHandling::continue == PCB::ErrorHandling)
						{
							// evaluate generic recovery
							EvaluateGenericRecovery(stepReturn);
							status = hslTrue;
						}
						else
							status = hslFalse;
						return(status);
					}
					if (StepType::calibrate1536Plate == stepType)
					{
						// set status
						if (ErrorHandling::continue == PCB::ErrorHandling)
						{
							// evaluate generic recovery
							EvaluateGenericRecovery(stepReturn);
							status = hslTrue;
						}
						else
							status = hslFalse;
						return(status);
					}
					if (StepType::waitNeedleWashed == stepType)
					{
						// set status
						if (ErrorHandling::continue == PCB::ErrorHandling)
						{
							// evaluate generic recovery
							EvaluateGenericRecovery(stepReturn);
							status = hslTrue;
						}
						else
							status = hslFalse;
						return(status);
					}
					if (StepType::startNeedleWash == stepType)
					{
						// set status
						if (ErrorHandling::continue == PCB::ErrorHandling)
						{
							// evaluate generic recovery
							EvaluateGenericRecovery(stepReturn);
							status = hslTrue;
						}
						else
							status = hslFalse;
						return(status);
					}
				}
				if (2 == errorCode)
				{
					// unrecoverable error,
					// re-throw error
					Error::RaiseLast();
				}
			}
			return(status);
		}

		static function EvaluateAspirateRecovery(
			variable& stepReturn,
			string& channelPattern)
		{
			variable status(hslTrue);		// evaluation status
			variable index(0);				// loop index
			variable length(0);				// string length
			variable mainError(0);			// main error code
			variable recoveryButton(0);	// recovery button

			// iterate over channels
			length = channelPattern.GetLength();
			for (index = 0; index < length; index++)
			{
				if ("1" == channelPattern.Mid(index, 1))
				{
					// channel is active,
					// get main error 
					mainError = StepReturn::GetMainError(index + 1, stepReturn);

					// check if the channel has an error
					if (MainError::noError != mainError)
					{
						// channel has an error,
						// get recovery option
						recoveryButton = StepReturn::GetRecoveryButton(index + 1, stepReturn);

						// handle insufficient liquid only 
						if (MainError::insufficientError == mainError ||
							MainError::lldNotFound == mainError)
						{
							// handle recovery option Continue
							if (RecoveryButton::cancel == recoveryButton)
							{
								// user selected Continue button
								status = hslFalse;
								return(status);
							}
						}

						// handle recovery options Abort and Cancel which are 
						// common to all main errors 
						if (RecoveryButton::abort_ == recoveryButton)
						{
							// user selected Abort button,
							// abort the method
							// Remark 1: we should never land here, because the executor 
							// already should have aborted the method.
							// Remark 2: a request to abort the method is signaled 
							// by raising the 'methodAborted ' error id
							Error::Raise(IDE::methodAborted, GetFileName(), GetFunctionName(), GetLineNumber());
						}
						if (RecoveryButton::cancel == recoveryButton)
						{
							// user selected Cancel button,
							// re-throw error
							Error::RaiseLast();
						}
					}
				}
			}

			return(status);
		}

		static function EvaluateGenericRecovery(
			variable& stepReturn)
		{
			variable index(0);					// loop index
			variable length(0);					// string length
			variable mainError(0);				// main error code
			variable recoveryButton(0);		// recovery button
			variable numberOfPositions(0);	// number of positions in step return

			// iterate over positons
			numberOfPositions = StepReturn::GetNumberOfPositions(stepReturn);
			for (index = 0; index < numberOfPositions; index++)
			{
				// get main error 
				mainError = StepReturn::GetMainError(index + 1, stepReturn);

				if (MainError::noError != mainError)
				{
					// channel has an error,
					// get recovery option
					recoveryButton = StepReturn::GetRecoveryButton(index + 1, stepReturn);

					// handle recovery options Abort and Cancel which are 
					// common to all main errors 
					if (RecoveryButton::abort_ == recoveryButton)
					{
						// user selected Abort button,
						// abort the method
						// Remark 1: we should never land here, because the executor 
						// already should have aborted the method.
						// Remark 2: a request to abort the method is signaled 
						// by raising the 'methodAborted ' error id
						Error::Raise(IDE::methodAborted, GetFileName(), GetFunctionName(), GetLineNumber());
					}
					if (RecoveryButton::cancel == recoveryButton)
					{
						// user selected Cancel button,
						// re-throw error
						Error::RaiseLast();
					}
				}
			}
		}

		static function SetData(
			variable& stepReturn,
			string& channelPattern)
		{
			variable index(0);				// loop index
			variable length(0);				// string length
			variable mainError(0);			// main error code

			// update previous repeat pattern 
			prevCopyPattern = channelPattern;
			// reset the repeat pattern
			copyPattern = "";

			// iterate over channels
			length = channelPattern.GetLength();
			for (index = 0; index < length; index++)
			{
				if ("1" == channelPattern.Mid(index, 1))
				{
					// channel is active,
					// get main error 
					mainError = StepReturn::GetMainError(index + 1, stepReturn);

					// check if the channel has an error
					if (MainError::noError != mainError)
					{
						// channel has an error,

						// channel is active and channel has an error 
						// update copyPattern by disabling channel
						copyPattern = copyPattern + "0";
					}
					else
					{
						// channel is active and has no error,
						// update copyPattern
						copyPattern = copyPattern + "1";
					}

				}
				else
				{
					// channel isn't active,
					// update copyPattern
					copyPattern = copyPattern + "0";
				}
			}
		}

		static function ResetData()
		{
			copyPattern = "";
			prevCopyPattern = "";
		}

		static function Dump(variable& rc[])
		{
			#ifdef _DEBUG
			variable index(0);
			for (index = 0; index < rc.GetSize(); index++)
				FormatTrace("DEBUG  ", "StepReturn::Dump()", TraceStatus::progress, "rc[", index, "] = ", rc.GetAt(index));
			#endif
		}

		static function IsRecovering()
		{
			return("" != copyPattern);
		}

		static function GetChannelPattern()
		{
			return(copyPattern);
		}

		static function GetPrevChannelPattern()
		{
			return(prevCopyPattern);
		}

		static function XorChannelPattern(
			string& channelPattern)
		{
			variable index(0);				// loop index
			variable length(0);				// string length
			variable xorPattern("");		// xor pattern
			string   cpyPattern;				// repeat pattern

			// iterate over channels
			cpyPattern = copyPattern;
			length = Util::Min(channelPattern.GetLength(), cpyPattern.GetLength());
			for (index = 0; index < length; index++)
			{
				if ("1" == channelPattern.Mid(index, 1) && "0" == cpyPattern.Mid(index, 1))
					xorPattern = xorPattern + "1";
				else
					xorPattern = xorPattern + "0";
			}
			return(xorPattern);
		}

		static function HandleError(
			device& ML_STAR,
			variable stepType)
		{
			variable rc[];									// step return array 

			#ifdef _DEBUG
			Assert(StepType::aspirate == stepType || 
					 StepType::getLastLiquidLevel == stepType, GetFunctionName());
			#endif

			if (StepType::aspirate == stepType)
			{
				// handle error here
			}
			return(rc);
		}

		static function DumpData()
		{
			#ifdef _DEBUG
			variable index(0);
			FormatTrace("DEBUG  ", "StepReturn::DumpData()", TraceStatus::progress, "copyPattern = ", copyPattern);
			FormatTrace("DEBUG  ", "StepReturn::DumpData()", TraceStatus::progress, "prevCopyPattern = ", prevCopyPattern);
			#endif
		}
	}


	static function GetInstTypeFromDevice( device ml_star ) variable
	{
		variable retVal[];
		variable index, strValue;
		string result;
		variable maxInstrumentTrays, maxLoadingTrays;
		variable instrumentNr(-1);
		variable fwCommand, fwParameter;

		variable traceSource, traceAction;


		fwCommand   = "C0QM";	// Request extended configuration
		fwParameter = "";

		// Note for 'Simulator Mode' (2004-04-14 / cjoerg):
		// If we are in the simulator mode the answer for "C0QM" (param 'xt','xa') is also valid and 
		// adapted for the installed / configured instrument.

		#ifdef _DEBUG
			Trace(fwCommand, fwParameter);
		#endif

		retVal = FirmwareCommand::Execute(ml_star, fwCommand, fwParameter);
		result = retVal.GetAt(retVal.GetSize() - 1);		// Get the result of executed command

		// Check for firmware error
		FirmwareError::ErrorCheck(result);

		// Instrument size in slots (X range)
		index = result.Find("xt");
		strValue = result.Mid((index+2), 2);
		#ifdef _DEBUG
			Trace("Extracted value for parameter 'xt' = ", strValue);
		#endif
		maxInstrumentTrays = IVal(strValue);
		#ifdef _DEBUG
			Trace("-> Instrument size in slots (IVal) = ", maxInstrumentTrays);
		#endif

		// Autoload size in slots
		index = result.Find("xa");
		strValue = result.Mid((index+2), 2);
		#ifdef _DEBUG
			Trace("Extracted value for parameter 'xa' = ", strValue);
		#endif
		maxLoadingTrays = IVal(strValue);
		#ifdef _DEBUG
			Trace("-> Autoload size in slots = ", maxLoadingTrays);
		#endif

		if ((maxInstrumentTrays == 54) && (maxLoadingTrays == 54))
			instrumentNr = 0;		// Microlab STAR
		else if ((maxInstrumentTrays == 30) && (maxLoadingTrays == 30))
			instrumentNr = 1;		// Microlab Starlet
		else if ((maxInstrumentTrays > 0) && (maxLoadingTrays > 0))
			instrumentNr = 2;		// Microlab STAR Plus
		else
			instrumentNr = -1;	// Kein gltiges Gert

		#ifdef _DEBUG
			Trace("Evaluated instrument type: ", instrumentNr, " (", ml_star.GetInstrumentName(), ")");
		#endif

		traceSource = StringTable::Load(HSLML_STAR::IDS::traceSource);
		traceAction = StringTable::Load(HSLML_STAR::IDS::evaluatedInstrumentType);
		traceAction = traceAction + IStr(instrumentNr);
		FormatTrace(traceSource, traceAction, 4); 

		return( instrumentNr );
	}


	static function GetInstType(variable& dummyLayout) variable
	{
		device dummyDevice(dummyLayout);
		variable instrumentType;

		instrumentType = GetInstTypeFromDevice(dummyDevice);

		return( instrumentType );
	}


	// --------------------------------------------------------------------------------------
	// Interface function GetInstrumentType
	// --------------------------------------------------------------------------------------

	function GetInstrumentType() variable
	{
		variable dummyLayout;
		variable traceSource, traceAction;
		variable instrumentType;

		// initialize the core of HSLML_STAR library
		InitHSLML_STARLibraryCore();

		traceSource = StringTable::Load(HSLML_STAR::IDS::traceSource);
		traceAction = StringTable::Load(HSLML_STAR::IDS::traceActionGetInstrumentTypeNoInstr);

		FormatTrace(traceSource, traceAction, 1); 

		dummyLayout = GetConfigPath()	+ "\\" + "Diagnostic.lay";

		// "Diagnostic.lay", stored in the config path by the installation.
		// Layout for an instrument 'ML_STAR' but without any information about the size
		// of the deck (the count of trays is set to -1).

		// May be used to create a local device and connect to a real instrument for query
		// its count of trays.

		instrumentType = GetInstType( dummyLayout );

		FormatTrace(traceSource, traceAction, 2); 

		return( instrumentType );
	}


	// --------------------------------------------------------------------------------------
	// Interface function GetInstrumentType_GlobalDevice
	// --------------------------------------------------------------------------------------

	function GetInstrumentType_GlobalDevice(device& ml_star) variable
	{
		variable traceSource, traceAction;
		variable instrumentType;

		// initialize the core of HSLML_STAR library
		InitHSLML_STARLibraryCore();

		traceSource = StringTable::Load(HSLML_STAR::IDS::traceSource);
		traceAction = StringTable::Load(HSLML_STAR::IDS::traceActionGetInstrumentType);
		traceAction = traceAction + ml_star.GetInstrumentName();

		FormatTrace(traceSource, traceAction, 1); 

		instrumentType = GetInstTypeFromDevice( ml_star );

		FormatTrace(traceSource, traceAction, 2); 

		return( instrumentType );
	}


	// --------------------------------------------------------------------------------------
	// Interface function IsSimulatorMode
	// --------------------------------------------------------------------------------------

	function IsSimulatorMode(device& ml_star) variable
	{
		variable simulatorMode;
		  const variable simulatorModeOff(0);
		//const variable simulatorModeOn (1);

		// initialize the core of HSLML_STAR library
		InitHSLML_STARLibraryCore();

		simulatorMode = ml_star.GetCfgValueWithKey(MlStarCfgKey::simulatorMode);

		if (		( hslInteger.Compare(GetType(simulatorMode)) == 0 )
				&& ( simulatorMode != simulatorModeOff ))
		{
			// is integer and not set to OFF -> this instrument is in the simulator mode.
			#ifdef _DEBUG
				Trace("Simulator Mode is ON (", ml_star.GetInstrumentName(), ")");
			#endif

			return( hslTrue );
		}

		#ifdef _DEBUG
			Trace("Simulator Mode is OFF (", ml_star.GetInstrumentName(), ")");
		#endif

		return( hslFalse );
	}

} // end of namespace HSLML_STAR

#endif  /* end of ifndef __HSLML_STARImpl_hsl__ */
// $$author=wbarmettler$$valid=1$$time=2010-07-05 07:04$$checksum=5c09a3eb$$length=090$$